
/* NOTE: This file is a *very* hacked up version of the original
teem/moss.h, generated by build_teem.py to declare the moss API to
CFFI, within its many limitations, specifically lacking a C pre-processor
(so no #include directives, and only certain #defines). */
 /* =========== moss.h =========== */
/*
  Teem: Tools to process and visualize scientific data and images
  Copyright (C) 2009--2023  University of Chicago
  Copyright (C) 2005--2008  Gordon Kindlmann
  Copyright (C) 1998--2004  University of Utah
  This library is free software; you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License (LGPL) as published by the Free Software
  Foundation; either version 2.1 of the License, or (at your option) any later version.
  The terms of redistributing and/or modifying this software also include exceptions to
  the LGPL that facilitate static linking.
  This library is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public License along with
  this library; if not, write to Free Software Foundation, Inc., 51 Franklin Street,
  Fifth Floor, Boston, MA 02110-1301 USA
*/
/* NOTE: this library has not undergone the changes as other Teem
   libraries in order to make sure that array lengths and indices
   are stored in unsigned types */
/* used by ilk, hence not in privateMoss.h */
/* how to learn chanNum for a given img Nrrd */
enum {
  mossFlagUnknown,    /* 0: nobody knows */
  mossFlagImage,      /* 1: image being sampled */
  mossFlagKernel,     /* 2: kernel(s) used for sampling */
  mossFlagChanNum,    /* 3: number of per-pixel channels */
  mossFlagFilterDiam, /* 4: kernel filter diameter */
  mossFlagLast
};
#define MOSS_FLAG_MAX 4
/* container for moss sampling. With July 2022 re-write, changed all floating-point
   types to double (from a confusing mix of float and double) */
typedef struct {
  int verbose,                 /* verbosity (set directly, rather than by a
                                  mossSampler..Set() function) */
    verbPixel[2];              /* debug pixel indices */
  const Nrrd *image;           /* the image to sample */
  int boundary;                /* from nrrdBoundary* enum */
  NrrdKernelSpec *kspec;       /* kernel to use on both (spatial) axes */
  unsigned int filterDiam,     /* filter diameter */
    chanNum;                   /* number of per-pixel channels */
  int *xIdx, *yIdx;            /* arrays for x and y indices into image
                                  both allocated for filterDiam */
  double *ivc,                 /* intermediate value cache, allocated for
                                  filterDiam x filterDiam x chanNum
                                  doubles, with that axis ordering */
    *xFslw, *yFslw,            /* filter sample locations->weights
                                  both allocated for filterDiam */
    *bg;                       /* background color. If non-NULL,
                                  allocated for chanNum, handled (unusually) by
                                  mossSamplerImageSet */
  int flag[MOSS_FLAG_MAX + 1]; /* I'm a flag-waving struct */
} mossSampler;
/* defaultsMoss.c */
extern const char *const mossBiffKey;
extern int mossDefCenter;
/* methodsMoss.c */
extern const int mossPresent;
extern mossSampler *mossSamplerNew(void);
extern mossSampler *mossSamplerNix(mossSampler *smplr);
extern int mossImageCheck(const Nrrd *image);
extern int mossImageAlloc(Nrrd *image, int type, unsigned int sx, unsigned int sy,
                               unsigned int chanNum);
/* sampler.c */
extern int mossSamplerImageSet(mossSampler *smplr, const Nrrd *image, int boundary,
                                    const double *bg);
extern int mossSamplerKernelSet(mossSampler *smplr, const NrrdKernelSpec *kspec);
extern int mossSamplerUpdate(mossSampler *smplr);
extern int mossSamplerSample(double *val, mossSampler *smplr, double xPos,
                                  double yPos);
/* hestMoss.c */
extern const hestCB *const mossHestTransform;
extern const hestCB *const mossHestOrigin;
/* xform.c */
extern void mossMatPrint(FILE *f, const double *mat);
extern double *mossMatRightMultiply(double *mat, const double *x);
extern double *mossMatLeftMultiply(double *mat, const double *x);
extern double *mossMatInvert(double *inv, const double *mat);
extern double *mossMatIdentitySet(double *mat);
extern double *mossMatTranslateSet(double *mat, double tx, double ty);
extern double *mossMatRotateSet(double *mat, double angle);
extern double *mossMatFlipSet(double *mat, double angle);
extern double *mossMatShearSet(double *mat, double angleFixed, double amount);
extern double *mossMatScaleSet(double *mat, double sx, double sy);
extern void mossMatApply(double *ox, double *oy, const double *mat, double ix,
                              double iy);
extern int mossLinearTransform(Nrrd *nout, const Nrrd *nin, int boundary,
                                    const double *bg, const double *mat,
                                    mossSampler *msp, double xMin, double xMax,
                                    double yMin, double yMax, int sx, int sy);
extern int mossFourPointTransform(Nrrd *nout, const Nrrd *nin, int boundary,
                                       const double *bg, const double xyc[8],
                                       mossSampler *msp, int xSize, int ySize);
