
/* NOTE: This file is a *very* hacked up version of the original
teem/air.h, generated by build_teem.py to declare the air API to
CFFI, within its many limitations, specifically lacking a C pre-processor
(so no #include directives, and only certain #defines). */
 /* =========== air.h =========== */
/*
  Teem: Tools to process and visualize scientific data and images
  Copyright (C) 2009--2023  University of Chicago
  Copyright (C) 2010 Thomas Schultz
  Copyright (C) 2005--2008  Gordon Kindlmann
  Copyright (C) 1998--2004  University of Utah
  This library is free software; you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License (LGPL) as published by the Free Software
  Foundation; either version 2.1 of the License, or (at your option) any later version.
  The terms of redistributing and/or modifying this software also include exceptions to
  the LGPL that facilitate static linking.
  This library is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public License along with
  this library; if not, write to Free Software Foundation, Inc., 51 Franklin Street,
  Fifth Floor, Boston, MA 02110-1301 USA
*/
/* ---- BEGIN non-NrrdIO */
/* ---- END non-NrrdIO */
/*
******** TEEM_VERSION
**
** TEEM_VERSION is a single (decimal) number that will always increase
** monotically, and the _MAJOR, _MINOR, _PATCH are also numbers that
** can be used to implement pre-processor logic about specifc
** versions.  The TEEM_VERSION_STRING is used in the (existing) char
** *airTeemVersion (added in version 1.9.0).  Yes, keeping these in
** sync is currently a manual operation.
**
** NOTE: Significant API changes (aside from API additions) should NOT
** occur with changes in patch level, only with major or minor version
** changes.
**
** NOTE: ../../CMakeLists.txt's Teem_VERSION variables must be in sync
*/
/* clang-format off */
#define TEEM_VERSION_MAJOR   1       /* must be 1 digit */
#define TEEM_VERSION_MINOR    12     /* 1 or 2 digits */
#define TEEM_VERSION_PATCH      00   /* 1 or 2 digits */
#define TEEM_VERSION         11200   /* must be 5 digits, to facilitate
                                        easy numerical comparison */
/* clang-format on */
/* NrrdIO-hack-000 */
/* NrrdIO-hack-001 */
typedef unsigned long long airULLong;
typedef signed long long airLLong;
/* ---- BEGIN non-NrrdIO */
/* ---- END non-NrrdIO */
/*
 * These serve as conservative estimates on how large various strings might end up being.
 * It would be theoretically better to completely avoid the use of fixed-size buffers,
 * but in many contexts the implementation complexity of handling them reliably is
 * distracts from more urgent implementation goals.  In the mean time, these can be used
 * safely as long as the lengths are used consistently.
 */
#define AIR_STRLEN_SMALL 128
/* SMALL has to be big enough to hold:
   - printed value of size_t and
   - ptrdiff_t, line of text that
   - should contain file format "magic"
*/
#define AIR_STRLEN_MED   256
#define AIR_STRLEN_LARGE 512
#define AIR_STRLEN_HUGE  1024
/* HUGE has to be big enough to hold one line of biff error message */
/*
******** airPtrPtrUnion
**
** union of addresses of pointers to various types, to deal with strict
** aliasing warnings, especially with the first argument to airArrayNew().
** Unfortunately this can't meet the needs of all such cases because some
** libraries need to manage addresses of arrays of other kinds of
** library-specific objects (about which air is ignorant).
*/
typedef union {
  unsigned char **uc;
  signed char **sc;
  char **c;
  char ***cp;
  unsigned short **us;
  short **s;
  unsigned int **ui;
  int **i;
  long int **li;
  float **f;
  double **d;
  void **v;
} airPtrPtrUnion;
/*
******** airEnum struct
**
** The airEnum provides the basic mechanism of mapping from a
** string to an int enum value, and back.
*/
typedef struct {
  const char *name;
  /* what are these things? */
  unsigned int M;
  /* str[0]: string for the unknown/invalid value;
     str[1] .. str[M]: canonical strings for the enum values;
     "val"     NULL: unknown/invalid = 0;
                     valid values are 1 .. M
     "val" non-NULL: unknown/invalid = val[0];
                     valid are val[1].. val[M]
  */
  const char **str; /* see above */
  const int *val;   /* see above */
  const char **desc;
  /* desc[i] is a short description of the enum values represented by
     str[i] (thereby starting with the unknown value), to be used to
     by things like hest */
  const char **strEqv;
  /* If non-NULL, all the variations in strings recognized in mapping
     from string to value (the values in valEqv).  This **MUST** be
     terminated by a zero-length string ("") so as to signify the end
     of the list.  This should *not* contain the string for
     unknown/invalid.  If "strEqv" is NULL, then mapping from string
     to value is done only by traversing "str", and "valEqv" is
     ignored. */
  const int *valEqv;
  /* If strEqv non-NULL, valEqv holds the values corresponding to the
     strings in strEqv, with one integer for each non-zero-length
     string in strEqv: strEqv[i] is a valid string representation for
     value valEqv[i]. This should *not* contain the value for
     unknown/invalid.  This "valEqv" is ignored if "strEqv" is
     NULL. */
  int sense; /* require case matching on strings */
} airEnum;
extern int airEnumUnknown(const airEnum *enm);
extern int airEnumValCheck(const airEnum *enm, int val);
extern const char *airEnumStr(const airEnum *enm, int val);
extern const char *airEnumDesc(const airEnum *enm, int val);
extern int airEnumVal(const airEnum *enm, const char *str);
extern char *airEnumFmtDesc(const airEnum *enm, int val, int canon, const char *fmt);
extern void airEnumPrint(FILE *file, const airEnum *enm);
/* ---- BEGIN non-NrrdIO */
extern int airEnumCheck(char err[AIR_STRLEN_LARGE + 1], const airEnum *enm);
/* ---- END non-NrrdIO */
/*
******** airEndian enum
**
** for identifying how a file was written to disk, for those encodings
** where the raw data on disk is dependent on the endianness of the
** architecture.
*/
enum {
  airEndianUnknown,       /* 0: nobody knows */
  airEndianLittle = 1234, /* 1234: Intel and friends */
  airEndianBig = 4321,    /* 4321: the rest */
  airEndianLast
};
/* endianAir.c */
extern const airEnum *const airEndian;
extern int airMyEndian(void);
/* array.c: poor-man's dynamically resizable arrays */
typedef struct {
  void *data,               /* where the data is */
    **dataP;                /* (possibly NULL) address of user's data variable,
                               kept in sync with internal "data" variable */
  unsigned int len,         /* length of array: # units for which there is
                               considered to be data (which is <= total # units
                               allocated).  The # bytes which contain data is
                               len*unit.  Always updated (unlike "*lenP") */
    *lenP,                  /* (possibly NULL) address of user's length variable,
                               kept in sync with internal "len" variable */
    incr,                   /* the granularity of the changes in amount of space
                               allocated: when the length reaches a multiple of
                               "incr", then the array is resized */
    size;                   /* array is allocated to have "size" increments, or,
                               size*incr elements, or,
                               size*incr*unit bytes */
  size_t unit;              /* the size in bytes of one element in the array */
  int noReallocWhenSmaller; /* as it says */
  /* the following are all callbacks useful for maintaining either an array
     of pointers (allocCB and freeCB) or array of structs (initCB and
     doneCB).  allocCB or initCB is called when the array length increases,
     and freeCB or doneCB when it decreases.  Any of them can be NULL if no
     such activity is desired.  allocCB sets values in the array (as in
     storing the return from malloc(); freeCB is called on values in the
     array (as in calling free()), and the values are cast to void*.  allocCB
     and freeCB don't care about the value of "unit" (though perhaps they
     should).  initCB and doneCB are called on the _addresses_ of elements in
     the array.  allocCB and initCB are called for the elements in ascending
     order in the array, and freeCB and doneCB are called in descending
     order.  allocCB and initCB are mutually exclusive- they can't both be
     non-NULL. Same goes for freeCB and doneCB */
  void *(*allocCB)(void);  /* values of new elements set to return of this */
  void *(*freeCB)(void *); /* called on the values of invalidated elements */
  void (*initCB)(void *);  /* called on addresses of new elements */
  void (*doneCB)(void *);  /* called on addresses of invalidated elements */
} airArray;
extern airArray *airArrayNew(void **dataP, unsigned int *lenP, size_t unit,
                                 unsigned int incr);
extern void airArrayStructCB(airArray *a, void (*initCB)(void *),
                                 void (*doneCB)(void *));
extern void airArrayPointerCB(airArray *a, void *(*allocCB)(void),
                                  void *(*freeCB)(void *));
extern void airArrayLenSet(airArray *a, unsigned int newlen);
/* ---- BEGIN non-NrrdIO */
extern void airArrayLenPreSet(airArray *a, unsigned int newlen);
/* ---- END non-NrrdIO */
extern unsigned int airArrayLenIncr(airArray *a, int delta);
extern airArray *airArrayNix(airArray *a);
extern airArray *airArrayNuke(airArray *a);
/* ---- BEGIN non-NrrdIO */
/* heap.c: a (mostly) standard binary min-heap, built on top of airArray.
 * Additional non-standard functionality includes storing additional
 * data and addressing elements that are not at the top of the heap */
typedef struct {
  airArray *key_a;    /* where the keys are */
  airArray *data_a;   /* where the data is */
  airArray *idx_a;    /* indices */
  airArray *invidx_a; /* inverse indices, to access arbitrary elements */
  double *key;
  void *data;
  unsigned int *idx;
  unsigned int *invidx;
} airHeap;
extern airHeap *airHeapNew(size_t dataUnit, unsigned int incr);
extern airHeap *airHeapFromArray(const airArray *key, const airArray *data);
extern airHeap *airHeapNix(airHeap *h);
extern unsigned int airHeapLength(const airHeap *h);
extern unsigned int airHeapInsert(airHeap *h, double key, const void *data);
extern unsigned int airHeapMerge(airHeap *first, const airHeap *second);
extern double airHeapFrontPeek(const airHeap *h, void *data);
extern double airHeapFrontPop(airHeap *h, void *data);
extern int airHeapFrontUpdate(airHeap *h, double newKey, const void *newData);
extern int airHeapFind(const airHeap *h, unsigned int *ai, const void *data);
extern int airHeapRemove(airHeap *h, unsigned int ai);
extern int airHeapUpdate(airHeap *h, unsigned int ai, double newKey,
                             const void *newData);
/* threadAir.c: simplistic wrapper functions for multi-threading  */
/*
********  airThreadCapable
**
** if non-zero: we have some kind of multi-threading available, either
** via pthreads, or via Windows stuff
*/
extern const int airThreadCapable;
/*
******** airThreadNoopWarning
**
** When multi-threading is not available, and hence constructs like
** mutexes are not available, the operations on them will be
** no-ops. When this variable is non-zero, we fprintf(stderr) a
** warning to this effect when those constructs are used
** (NOTE that this is a mutable global variable)
*/
extern int airThreadNoopWarning;
/* opaque typedefs for OS-specific stuff */
typedef struct _airThread airThread;
typedef struct _airThreadMutex airThreadMutex;
typedef struct _airThreadCond airThreadCond;
typedef struct {
  unsigned int numUsers, numDone;
  airThreadMutex *doneMutex;
  airThreadCond *doneCond;
} airThreadBarrier;
extern airThread *airThreadNew(void);
extern int airThreadStart(airThread *thread, void *(*threadBody)(void *), void *arg);
extern int airThreadJoin(airThread *thread, void **retP);
extern airThread *airThreadNix(airThread *thread);
extern airThreadMutex *airThreadMutexNew(void);
extern int airThreadMutexLock(airThreadMutex *mutex);
extern int airThreadMutexUnlock(airThreadMutex *mutex);
extern airThreadMutex *airThreadMutexNix(airThreadMutex *mutex);
extern airThreadCond *airThreadCondNew(void);
extern int airThreadCondWait(airThreadCond *cond, airThreadMutex *mutex);
extern int airThreadCondSignal(airThreadCond *cond);
extern int airThreadCondBroadcast(airThreadCond *cond);
extern airThreadCond *airThreadCondNix(airThreadCond *cond);
extern airThreadBarrier *airThreadBarrierNew(unsigned numUsers);
extern int airThreadBarrierWait(airThreadBarrier *barrier);
extern airThreadBarrier *airThreadBarrierNix(airThreadBarrier *barrier);
/* ---- END non-NrrdIO */
/*
******** airFP enum
**
** the different kinds of floating point number afforded by IEEE 754,
** and the values returned by airFPClass_f().
**
** The values probably won't agree with those in #include's like
** ieee.h, ieeefp.h, fp_class.h.  This is because IEEE 754 hasn't
** defined standard values for these, so everyone does it differently.
**
** This enum uses underscores (against Teem convention) to help
** legibility while also conforming to the spirit of the somewhat
** standard naming conventions
*/
enum {
  airFP_Unknown,    /*  0: nobody knows */
  airFP_SNAN,       /*  1: signalling NaN */
  airFP_QNAN,       /*  2: quiet NaN */
  airFP_POS_INF,    /*  3: positive infinity */
  airFP_NEG_INF,    /*  4: negative infinity */
  airFP_POS_NORM,   /*  5: positive normalized non-zero */
  airFP_NEG_NORM,   /*  6: negative normalized non-zero */
  airFP_POS_DENORM, /*  7: positive denormalized non-zero */
  airFP_NEG_DENORM, /*  8: negative denormalized non-zero */
  airFP_POS_ZERO,   /*  9: +0.0, positive zero */
  airFP_NEG_ZERO,   /* 10: -0.0, negative zero */
  airFP_Last        /* after the last valid one */
};
#define AIR_FP_MAX 10
/* 754.c: IEEE-754 related stuff values */
typedef union {
  unsigned int i;
  float f;
} airFloat;
typedef union {
  airULLong i;
  double d;
} airDouble;
extern const airEnum *const airFPClass_ae;
extern const unsigned int airMyQNaNHiBit;
extern float airFPPartsToVal_f(unsigned int sign,
                                   unsigned int expo,
                                   unsigned int mant);
extern void airFPValToParts_f(unsigned int *signP, unsigned int *expoP,
                                  unsigned int *mantP, float v);
extern double airFPPartsToVal_d(unsigned int sign,
                                    unsigned int expo,
                                    unsigned int mant0,
                                    unsigned int mant1);
extern void airFPValToParts_d(unsigned int *signP,
                                  unsigned int *expoP,
                                  unsigned int *mant0P,
                                  unsigned int *mant1P,
                                  double v);
extern float airFPGen_f(int cls);
extern double airFPGen_d(int cls);
extern int airFPClass_f(float val);
extern int airFPClass_d(double val);
extern void airFPFprintf_f(FILE *file, float val);
extern void airFPFprintf_d(FILE *file, double val);
extern const airFloat airFloatQNaN;
extern const airFloat airFloatSNaN;
extern const airFloat airFloatPosInf;
extern const airFloat airFloatNegInf;
extern float airNaN(void);
extern int airIsNaN(double d);
extern int airIsInf_f(float f);
extern int airIsInf_d(double d);
extern int airExists(double d);
/* ---- BEGIN non-NrrdIO */
#define AIR_RANDMT_N 624
typedef struct {
  /* These need to be at least 32 bits */
  unsigned int state[AIR_RANDMT_N], /* internal state */
    *pNext,                         /* next value to get from state */
    left;                           /* number of values left before
                                       reload needed */
} airRandMTState;
/* randMT.c */
extern airRandMTState *airRandMTStateGlobal;
extern void airRandMTStateGlobalInit(void);
extern airRandMTState *airRandMTStateNew(unsigned int seed);
extern airRandMTState *airRandMTStateNix(airRandMTState *state);
extern void airSrandMT_r(airRandMTState *state, unsigned int seed);
extern double airDrandMT_r(airRandMTState *state); /* [0,1] */
extern unsigned int airUIrandMT_r(airRandMTState *state);
extern double airDrandMT53_r(airRandMTState *state); /* [0,1) */
extern unsigned int airRandInt(unsigned int N);
extern unsigned int airRandInt_r(airRandMTState *state, unsigned int N);
extern void airSrandMT(unsigned int seed);
extern double airDrandMT(void);
extern int airRandMTSanity(void);
/* "Jenkins Small Fast" (psuedo)random number generator */
typedef struct {
  unsigned int a, b, c, d;
} airJSFRand;
/* randJSF.c */
extern airJSFRand *airJSFRandNew(unsigned int seed);
extern airJSFRand *airJSFRandNix(airJSFRand *jsf);
extern void airJSFRandSeed(airJSFRand *jsf, unsigned int seed);
extern unsigned int airJSFRandVal(airJSFRand *jsf);
extern unsigned int airJSFRandValMod(airJSFRand *jsf, unsigned int N);
extern float airJSFRandUni_f(airJSFRand *jsf);   /* [0,1) */
extern float airJSFRandBiUni_f(airJSFRand *jsf); /* (-1,1) */
extern float airJSFRandNormal_f(airJSFRand *jsf);
extern void airJSFRandNormal2_f(airJSFRand *jsf, float val[2]);
extern double airJSFRandUni_d(airJSFRand *jsf);   /* [0,1) */
extern double airJSFRandBiUni_d(airJSFRand *jsf); /* (-1,1) */
extern double airJSFRandNormal_d(airJSFRand *jsf);
extern void airJSFRandNormal2_d(airJSFRand *jsf, double val[2]);
extern int airJSFRandSanity(void);
/* ---- END non-NrrdIO */
/*
******** airType
**
** Different types which air cares about.
** Currently only used in the command-line parsing, but perhaps will
** be used elsewhere in air later
*/
enum {
  airTypeUnknown,  /*  0 */
  airTypeBool,     /*  1 */
  airTypeInt,      /*  2 */
  airTypeUInt,     /*  3 */
  airTypeLongInt,  /*  4 */
  airTypeULongInt, /*  5 */
  airTypeSize_t,   /*  6 */
  airTypeFloat,    /*  7 */
  airTypeDouble,   /*  8 */
  airTypeChar,     /*  9 */
  airTypeString,   /* 10 */
  airTypeEnum,     /* 11 */
  airTypeOther,    /* 12 */
  airTypeLast
};
#define AIR_TYPE_MAX 12
/* parseAir.c */
extern double airAtod(const char *str);
extern int airSingleSscanf(const char *str, const char *fmt, void *ptr);
extern const airEnum *const airBool;
extern unsigned int airParseStrB(int *out, const char *s, const char *ct,
                                     unsigned int n, ... /* (nothing used) */);
extern unsigned int airParseStrI(int *out, const char *s, const char *ct,
                                     unsigned int n, ... /* (nothing used) */);
extern unsigned int airParseStrUI(unsigned int *out, const char *s, const char *ct,
                                      unsigned int n, ... /* (nothing used) */);
extern unsigned int airParseStrLI(long int *out, const char *s, const char *ct,
                                      unsigned int n, ... /* (nothing used) */);
extern unsigned int airParseStrULI(unsigned long int *out, const char *s,
                                       const char *ct, unsigned int n,
                                       ... /* (nothing used) */);
extern unsigned int airParseStrZ(size_t *out, const char *s, const char *ct,
                                     unsigned int n, ... /* (nothing used) */);
extern unsigned int airParseStrF(float *out, const char *s, const char *ct,
                                     unsigned int n, ... /* (nothing used) */);
extern unsigned int airParseStrD(double *out, const char *s, const char *ct,
                                     unsigned int n, ... /* (nothing used) */);
extern unsigned int airParseStrC(char *out, const char *s, const char *ct,
                                     unsigned int n, ... /* (nothing used) */);
extern unsigned int airParseStrS(char **out, const char *s, const char *ct,
                                     unsigned int n,
                                     ... /* REQ'D even if n>1: int greedy */);
extern unsigned int airParseStrE(int *out, const char *s, const char *ct,
                                     unsigned int n, ... /* REQUIRED: airEnum *e */);
extern unsigned int (*const airParseStr[AIR_TYPE_MAX + 1])(void *, const char *,
                                                               const char *,
                                                               unsigned int, ...);
/* string.c */
extern char *airStrdup(const char *s);
extern size_t airStrlen(const char *s);
/* ---- BEGIN non-NrrdIO */
extern int airStrcmp(const char *s1, const char *s2);
/* ---- END non-NrrdIO */
extern int airStrtokQuoting;
extern char *airStrtok(char *s, const char *ct, char **last);
extern unsigned int airStrntok(const char *s, const char *ct);
extern char *airStrtrans(char *s, char from, char to);
extern char *airStrcpy(char *dst, size_t dstSize, const char *src);
extern int airEndsWith(const char *s, const char *suff);
extern char *airUnescape(char *s);
extern char *airOneLinify(char *s);
extern char *airToLower(char *str);
extern char *airToUpper(char *str);
extern unsigned int airOneLine(FILE *file, char *line, unsigned int size);
/* sane.c */
/*
******** airInsane enum
**
** reasons for why airSanity() failed (specifically, the possible
** return values for airSanity()
*/
enum {
  airInsane_not,           /*  0: actually, all sanity checks passed */
  airInsane_endian,        /*  1: airMyEndian is wrong */
  airInsane_pInfExists,    /*  2: AIR_EXISTS(positive infinity) was true */
  airInsane_nInfExists,    /*  3: AIR_EXISTS(negative infinity) was true */
  airInsane_NaNExists,     /*  4: AIR_EXISTS(NaN) was true */
  airInsane_ExistsBad,     /*  5: AIR_EXISTS of some finite values was false */
  airInsane_FltDblFPClass, /*  6: double -> float assignment messed up the
                               airFPClass_f() of the value */
  airInsane_QNaNHiBit,     /*  7: airMyQNaNHiBit is wrong */
  airInsane_AIR_NAN,       /*  8: airFPClass_f(AIR_QNAN) wrong
                                  (no longer checking on problematic SNAN) */
  airInsane_dio,           /*  9: airMyDio set to something invalid */
  airInsane_UCSize,        /* 10: unsigned char isn't 8 bits */
  airInsane_FISize,        /* 11: sizeof(float), sizeof(int) not 4 */
  airInsane_DLSize,        /* 12: sizeof(double), sizeof(airLLong) not 8 */
  airInsane_last
};
#define AIR_INSANE_MAX 12
extern const char *airInsaneErr(int insane);
extern int airSanity(void);
/* miscAir.c */
extern const char *const airTeemVersion;
extern const int airTeemReleaseDone;
extern const char *const airTeemReleaseDate;
extern void airTeemVersionSprint(char buff[AIR_STRLEN_LARGE + 1]);
extern void *airNull(void);
extern void *airSetNull(void **ptrP);
extern void *airFree(void *ptr);
extern FILE *airFopen(const char *name, FILE *std, const char *mode);
extern FILE *airFclose(FILE *file);
extern int airSinglePrintf(FILE *file, char *str, const char *fmt, ...);
extern char *airSprintSize_t(char str[AIR_STRLEN_SMALL + 1], size_t val);
/* ---- BEGIN non-NrrdIO */
extern char *airSprintVecSize_t(char *str, const size_t *vec, unsigned int len);
extern char *airPrettySprintSize_t(char str[AIR_STRLEN_SMALL + 1], size_t v);
extern char *airSprintPtrdiff_t(char str[AIR_STRLEN_SMALL + 1], ptrdiff_t v);
extern const int airPresent;
extern FILE *airStderr(void);
extern FILE *airStdout(void);
extern FILE *airStdin(void);
extern unsigned int airBitsSet(unsigned int N);
extern unsigned int airIndex(double min, double val, double max, unsigned int N);
extern unsigned int airIndexClamp(double min, double val, double max,
                                      unsigned int N);
extern airULLong airIndexULL(double min, double val, double max, airULLong N);
extern airULLong airIndexClampULL(double min, double val, double max, airULLong N);
extern char *airDoneStr(double start, double here, double end, char *str);
extern double airTime(void);
extern const char airTypeStr[AIR_TYPE_MAX + 1][AIR_STRLEN_SMALL + 1];
extern const size_t airTypeSize[AIR_TYPE_MAX + 1];
extern void airEqvAdd(airArray *eqvArr, unsigned int j, unsigned int k);
extern unsigned int airEqvMap(airArray *eqvArr, unsigned int *map, unsigned int len);
extern unsigned int airEqvSettle(unsigned int *map, unsigned int len);
/* math.c */
extern double airFastExp(double val);
extern double airExp(double val);
extern void airNormalRand(double *z1, double *z2);
extern void airNormalRand_r(double *z1, double *z2, airRandMTState *state);
extern void airShuffle(unsigned int *buff, unsigned int N, int perm);
extern void airShuffle_r(airRandMTState *state, unsigned int *buff, unsigned int N,
                             int perm);
extern double airCbrt(double);
extern double airMode3(double a, double b, double c);
extern double airMode3_d(const double v[3]);
extern double airSgnPow(double, double);
extern double airFlippedSgnPow(double, double);
extern double airIntPow(double v, int p);
extern int airLog2(size_t n);
extern int airSgn(double);
extern size_t airIndexMirror64(ptrdiff_t I, size_t N);
extern unsigned int airIndexMirror32(int I, unsigned int N);
extern double airErfc(double x);
extern double airErf(double x);
extern double airGaussian(double x, double mean, double stdv);
extern double airBesselI0(double x);
extern double airBesselI1(double x);
extern double airBesselI0ExpScaled(double x);
extern double airBesselI1ExpScaled(double x);
extern double airLogBesselI0(double x);
extern double airLogRician(double mes, double tru, double sig);
extern double airRician(double mes, double tru, double sig);
extern double airBesselI1By0(double x);
extern double airBesselIn(int n, double x);
extern double airBesselInExpScaled(int n, double x);
extern double airTauOfTime(double tee);
extern double airTimeOfTau(double tau);
extern double airSigmaOfTau(double tau);
extern double airTauOfSigma(double sig);
extern double airVanDerCorput(unsigned int indx, unsigned int base);
extern void airHalton(double *out, unsigned int indx, const unsigned int *base,
                          unsigned int num);
#define AIR_PRIME_NUM 1000
extern const unsigned int airPrimeList[AIR_PRIME_NUM];
extern unsigned int airCRC32(const unsigned char *data, size_t len, size_t unit,
                                 int swap);
/* ---- END non-NrrdIO */
/* dio.c */
/*
******** airNoDio enum
**
** reasons for why direct I/O won't be used with a particular
** file/pointer combination
*/
enum {
  airNoDio_okay,    /*  0: actually, you CAN do direct I/O */
  airNoDio_arch,    /*  1: Teem thinks this architecture can't do it */
  airNoDio_format,  /*  2: Teem thinks given data file format can't use it */
  airNoDio_std,     /*  3: DIO isn't possible for std{in|out|err} */
  airNoDio_fd,      /*  4: couldn't get underlying file descriptor */
  airNoDio_dioinfo, /*  5: calling fcntl() to get direct I/O info failed */
  airNoDio_small,   /*  6: requested size is too small */
  airNoDio_size,    /*  7: requested size not a multiple of d_miniosz */
  airNoDio_ptr,     /*  8: pointer not multiple of d_mem */
  airNoDio_fpos,    /*  9: current file position not multiple of d_miniosz */
  airNoDio_setfl,   /* 10: fcntl(fd, SETFL, FDIRECT) failed */
  airNoDio_test,    /* 11: couldn't memalign() even a small bit of memory */
  airNoDio_disable, /* 12: someone disabled it with airDisableDio */
  airNoDio_last
};
#define AIR_NODIO_MAX 12
extern const char *airNoDioErr(int noDio);
extern const int airMyDio;
extern int airDisableDio;
extern void airDioInfo(int *align, int *min, int *max, int fd);
extern int airDioTest(int fd, const void *ptr, size_t size);
extern void *airDioMalloc(size_t size, int fd);
extern size_t airDioRead(int fd, void *ptr, size_t size);
extern size_t airDioWrite(int fd, const void *ptr, size_t size);
/* mop.c: clean-up utilities */
enum {
  airMopNever,
  airMopOnError,
  airMopOnOkay,
  airMopAlways
};
typedef void *(*airMopper)(void *);
typedef struct {
  void *ptr;     /* the thing to be processed */
  airMopper mop; /* the function to which does the processing */
  int when;      /* from the airMopWhen enum */
} airMop;
extern airArray *airMopNew(void);
extern int airMopAdd(airArray *arr, void *ptr, airMopper mop, int when);
extern void airMopSub(airArray *arr, void *ptr, airMopper mop);
extern void airMopMem(airArray *arr, void *_ptrP, int when);
extern void airMopUnMem(airArray *arr, void *_ptrP);
extern void airMopPrint(airArray *arr, const void *_str, int when);
extern void airMopDone(airArray *arr, int error);
extern void airMopError(airArray *arr);
extern void airMopOkay(airArray *arr);
extern void airMopDebug(airArray *arr);
/* ---- BEGIN non-NrrdIO */
extern void airMopSingleDone(airArray *arr, void *ptr, int error);
extern void airMopSingleError(airArray *arr, void *ptr);
extern void airMopSingleOkay(airArray *arr, void *ptr);
/* ---- END non-NrrdIO */
/*******     the interminable sea of defines and macros     *******/
#define AIR_TRUE  1
#define AIR_FALSE 0
/*
******** AIR_UNUSED
**
** one way of reconciling "warning: unused parameter" with
** C's "error: parameter name omitted"
*/
/*
******** AIR_CAST, AIR_UINT, AIR_INT, ...
**
** just casts, but with the added ability to grep for them more easily,
** since casts should probably always be revisited and reconsidered.
*/
/*
******** AIR_VOIDP, AIR_CVOIDP
**
** explicit casting to "void *" (and "const void *") from non-void* pointers
** is strictly speaking needed for the %p format specifier in printf-like
** functions; this is a slightly more convenient form
*/
/*
******** AIR_MALLOC, AIR_CALLOC
**
** slightly simpler wrapper around cast and malloc/calloc
**
** HEY note that "T" is not guarded by parentheses in its first usage,
** as arguments in Teem macros normally are
*/
/*
******** AIR_ENDIAN, AIR_QNANHIBIT, AIR_DIO
**
** These reflect particulars of hardware which we're running on. The
** difference from the things starting with TEEM_ is that the TEEM_
** values are for passing architecture-specific to compilation of source
** files, and thes AIR_ variables are for advertising that information
** to anyone linking against air (or Teem) and including air.h.
*/
/*
******** AIR_NAN, AIR_QNAN, AIR_SNAN, AIR_POS_INF, AIR_NEG_INF
**
** its nice to have these values available without the cost of a
** function call.
**
** NOTE: AIR_POS_INF and AIR_NEG_INF correspond to the _unique_
** bit-patterns which signify positive and negative infinity.  With
** the NaNs, however, they are only one of many possible
** representations.
*/
/*
******** AIR_EXISTS(x)
**
** Is non-zero (true) only for x which are not NaN or +/-infinity. Modern C has
** isfinite() for the same purpose. Teem development started prior to isfinite() being
** reliably available on the platforms it ran on, and the terminology of "exists" rather
** than "finite" now pervades Teem source code.
**
** Much commentary, from a wide-eyed student GLK, used to be here.  The upshot:
** - Some compilers, with some options, violate IEEE 754 on x == x being false for NaNs
**   (but, that's moot for this macro because inf == inf).
** - GLK now believes that whether denormals are flushed to zero, and the role of
**   extended precision FP registers, are also moot for this macro, but welcomes
**   counterexamples or expert guidance.
**
** The current definition based on "!(x-x)" has seemed to work since 2012.  With
** -Wfloat-conversion, Clang warns that "implicit conversion turns floating-point number
** into integer" with x-x being the operand of "!", which is unfortunate. But there is
** no undefined behavior, at least as detected by clang -fsanitize=undefined, in !NaN
** (as arising from !(NaN-NaN) or !(inf-inf)). BTW GLK is unsure why the current macro
** explicitly casts the result of "!" to int, since "!" already produces an int:
** https://en.cppreference.com/w/c/language/operator_logical. A more straight-forward
** alternative, which avoids float conversion warnings, would be to use "x-x == x-x".
**
** Configuring with CMake uses teem/CMake/testAIR_EXISTS.c to test this macro (but NOTE:
** it has to be copy-pasted to there since it can't read air.h), which then produces
** teem-install-dir/include/teem/airExistsConf.h, which #define's AIR_EXISTS_MACRO_FAILS
** or not, which controls whether AIR_EXISTS uses the clever macro or the more reliable
** function call airExists. Still, there may be failure modes untested by
** testAIR_EXISTS.c, and by the tests in air/airSanity().
*/
/* ---- BEGIN non-NrrdIO */
/* clang-format off */
/*
******** AIR_EXISTS_F(x)
**
** This is another way to check for non-specialness (not NaN, not +inf, not -inf) of
** a _float_ _variable_, by making sure the exponent field isn't all ones.
**
** Unlike with AIR_EXISTS() or airExists(), this macro argument MUST be a variable of
** type (4-byte) float, and 4 == sizeof(int): there is no implicit type converstion as
** part of macro expansion.
**
** This macro is endian-safe.
*/
/*
******** AIR_EXISTS_D(x)
**
** like AIR_EXISTS_F(), but the argument here MUST be a (8-byte) double variable
*/
/*
******** AIR_ISNAN_F(x)
**
** detects if a float is NaN by looking at the bits, without relying on any of its
** arithmetic properties.  As with AIR_EXISTS_F(), this only works when the argument
** is a float variable, and when floats and ints are 4-bytes.
*/
/* ---- END non-NrrdIO */
/*
******** AIR_MAX(a,b), AIR_MIN(a,b), AIR_ABS(a)
**
** the usual
*/
/*
******** AIR_COMPARE(a,b)
**
** the sort of compare that qsort() wants for ascending sort
*/
/*
******** AIR_IN_OP(a,b,c), AIR_IN_CL(a,b,c)
**
** is true if the middle argument is in the open/closed interval
** defined by the first and third arguments
**
** AIR_IN_OP is new name for old AIR_BETWEEN
** AIR_IN_CL is new name for old AIR_INSIDE
*/
/*
******** AIR_CLAMP(a,b,c)
**
** returns the middle argument, after being clamped to the closed
** interval defined by the first and third arguments
*/
/*
******** AIR_MOD(i, N)
**
** returns that integer in [0, N-1] which is i plus a multiple of N. It
** may be unfortunate that the expression (i)%(N) appears three times;
** this should be inlined.  Or perhaps the compiler's optimizations
** (common sub-expression elimination) will save us.
**
** Note: integer divisions are not very fast on some modern chips;
** don't go silly using this one.
*/
/*
******** AIR_LERP(w, a, b)
**
** returns a when w=0, and b when w=1, and linearly varies in between
*/
/*
******** AIR_AFFINE(i,x,I,o,O)
**
** given intervals [i,I], [o,O] and a value x which may or may not be
** inside [i,I], return the value y such that y stands in the same
** relationship to [o,O] that x does with [i,I].  Or:
**
**    y - o         x - i
**   -------   =   -------
**    O - o         I - i
**
** It is the callers responsibility to make sure I-i and O-o are
** both non-zero.  Strictly speaking, real problems arise only when
** when I-i is zero: division by zero generates either NaN or infinity
**
** NOTE that "x" is evaluated only once (which makes this more useful),
** as is "I" and "O" (usually not so important); "i" and "o" are each
** evaluated twice
*/
/*
******** AIR_DELTA(i,x,I,o,O)
**
** given intervals [i,I] and [o,O], calculates the number y such that
** a change of x within [i,I] is proportional to a change of y within
** [o,O].  Or:
**
**      y             x
**   -------   =   -------
**    O - o         I - i
**
** It is the callers responsibility to make sure I-i and O-o are
** both non-zero
**
** NOTE that all arguments are evaluated only once
*/
/*
******** AIR_ROUNDUP, AIR_ROUNDDOWN
**
** rounds integers up or down; just wrappers around floor and ceil
*/
