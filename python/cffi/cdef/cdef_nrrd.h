
/* NOTE: This file is a *very* hacked up version of the original
teem/nrrd.h, generated by build_teem.py to declare the nrrd API to
CFFI, within its many limitations, specifically lacking a C pre-processor
(so no #include directives, and only certain #defines). */
 /* =========== nrrdEnums.h =========== */
/*
  Teem: Tools to process and visualize scientific data and images
  Copyright (C) 2009--2023  University of Chicago
  Copyright (C) 2005--2008  Gordon Kindlmann
  Copyright (C) 1998--2004  University of Utah
  This library is free software; you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License (LGPL) as published by the Free Software
  Foundation; either version 2.1 of the License, or (at your option) any later version.
  The terms of redistributing and/or modifying this software also include exceptions to
  the LGPL that facilitate static linking.
  This library is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public License along with
  this library; if not, write to Free Software Foundation, Inc., 51 Franklin Street,
  Fifth Floor, Boston, MA 02110-1301 USA
*/
/*******
******** NONE of these enums should have values set explicitly in their
******** definition.  The values should simply start at 0 (for Unknown)
******** and increase one integer per value.  The _nrrdCheckEnums()
******** sanity check assumes this, and there is no reason to use
******** explicit values for any of the enums.
*******/
/*
******** nrrdIoState* enum
**
** the various things it makes sense to get and set in nrrdIoState struct
** via nrrdIoStateGet and nrrdIoStateSet
** BUT HEY are those functions actually used (as opposed to directly reading
** or setting fields in the nio)?  GLK honestly forgot about those functions
** until working on adding nio->moreThanFloatInText
*/
enum {
  nrrdIoStateUnknown,
  nrrdIoStateDetachedHeader,
  nrrdIoStateBareText,
  nrrdIoStateMoreThanFloatInText,
  nrrdIoStateCharsPerLine,
  nrrdIoStateValsPerLine,
  nrrdIoStateSkipData,
  nrrdIoStateKeepNrrdDataFileOpen,
  nrrdIoStateZlibLevel,
  nrrdIoStateZlibStrategy,
  nrrdIoStateBzip2BlockSize,
  nrrdIoStateLast
};
/*
******** nrrdFormatType* enum
**
** the different file formats which nrrd supports
*/
enum {
  nrrdFormatTypeUnknown,
  nrrdFormatTypeNRRD, /* 1: basic nrrd format (associated with any of
                         the magics starting with "NRRD") */
  nrrdFormatTypePNM,  /* 2: PNM image */
  nrrdFormatTypePNG,  /* 3: PNG image */
  nrrdFormatTypeVTK,  /* 4: VTK Structured Points datasets (v1.0 and 2.0) */
  nrrdFormatTypeText, /* 5: ASCII text for 2D arrays, which may or may
                            not be bare (i.e. just numbers, no header
                            lines that start with "#") according
                            to NrrdIoState->bareText */
  nrrdFormatTypeEPS,  /* 6: Encapsulated PostScript (write-only) */
  nrrdFormatTypeLast
};
#define NRRD_FORMAT_TYPE_MAX 6
/*
******** nrrdBoundary* enum
**
** when resampling, how to deal with the ends of a scanline
*/
enum {
  nrrdBoundaryUnknown,
  nrrdBoundaryPad,    /* 1: fill with some user-specified value */
  nrrdBoundaryBleed,  /* 2: copy the last/first value out as needed */
  nrrdBoundaryWrap,   /* 3: wrap-around */
  nrrdBoundaryWeight, /* 4: normalize the weighting on the existing samples;
                         ONLY sensible for a strictly positive kernel
                         which integrates to unity (as in blurring) */
  nrrdBoundaryMirror, /* 5: mirror folding */
  nrrdBoundaryLast
};
#define NRRD_BOUNDARY_MAX 5
/*
******** nrrdType* enum
**
** all the different types, identified by integer
**
** 18 July 03: After some consternation, GLK decided to set
** nrrdTypeUnknown and nrrdTypeDefault to the same thing, with the
** reasoning that the only times that nrrdTypeDefault is used is when
** controlling an *output* type (the type of "nout"), or rather,
** choosing not to control an output type.  As output types must be
** known, there is no confusion between being unset/unknown (invalid)
** and being simply default.
*/
enum {
  nrrdTypeUnknown = 0, /*  0: signifies "type is unset/unknown" */
  nrrdTypeDefault = 0, /*  0: signifies "determine output type for me" */
  nrrdTypeChar,        /*  1:   signed 1-byte integer */
  nrrdTypeUChar,       /*  2: unsigned 1-byte integer */
  nrrdTypeShort,       /*  3:   signed 2-byte integer */
  nrrdTypeUShort,      /*  4: unsigned 2-byte integer */
  nrrdTypeInt,         /*  5:   signed 4-byte integer */
  nrrdTypeUInt,        /*  6: unsigned 4-byte integer */
  nrrdTypeLLong,       /*  7:   signed 8-byte integer */
  nrrdTypeULLong,      /*  8: unsigned 8-byte integer */
  nrrdTypeFloat,       /*  9:          4-byte floating point */
  nrrdTypeDouble,      /* 10:          8-byte floating point */
  nrrdTypeBlock,       /* 11: size user defined at run time; MUST BE LAST */
  nrrdTypeLast
};
#define NRRD_TYPE_MAX      11
/*
******** nrrdEncodingType enum
**
** how data might be encoded into a bytestream
*/
enum {
  nrrdEncodingTypeUnknown,
  nrrdEncodingTypeRaw,   /* 1: same as memory layout (modulo endianness) */
  nrrdEncodingTypeAscii, /* 2: decimal values are spelled out in ascii */
  nrrdEncodingTypeHex,   /* 3: hexidecimal (two chars per byte) */
  nrrdEncodingTypeGzip,  /* 4: gzip'ed raw data */
  nrrdEncodingTypeBzip2, /* 5: bzip2'ed raw data */
  nrrdEncodingTypeZRL,   /* 6: zero run-length compresion */
  nrrdEncodingTypeLast
};
#define NRRD_ENCODING_TYPE_MAX 6
/*
******** nrrdZlibStrategy enum
**
** how gzipped data is compressed
*/
enum {
  nrrdZlibStrategyUnknown,
  nrrdZlibStrategyDefault,  /* 1: default (Huffman + string match) */
  nrrdZlibStrategyHuffman,  /* 2: Huffman only */
  nrrdZlibStrategyFiltered, /* 3: specialized for filtered data */
  nrrdZlibStrategyLast
};
#define NRRD_ZLIB_STRATEGY_MAX 3
/*
******** nrrdCenter enum
**
** node-centered vs. cell-centered
*/
enum {
  nrrdCenterUnknown, /* 0: no centering known for this axis */
  nrrdCenterNode,    /* 1: samples at corners of things
                        (how "voxels" are usually imagined)
                        |\______/|\______/|\______/|
                        X        X        X        X   */
  nrrdCenterCell,    /* 2: samples at middles of things
                        (characteristic of histogram bins)
                         \___|___/\___|___/\___|___/
                             X        X        X       */
  nrrdCenterLast
};
#define NRRD_CENTER_MAX 2
/*
******** nrrdKind enum
**
** For describing the information along one axis of an array.  This is
** most important for clarifying the representation of non-scalar
** data, in order to distinguish between axes that are genuine image
** domain axes, and axes that exist just to store the multiple
** attributes per sample.  One could argue that this information
** should be per-array and not per-axis, but you still have to
** indicate which one of the axes is the attribute axis.  And, if you
** have, say, the gradient of RGB colors, you want the per-pixel 3x3
** array to have those two attribute axes tagged accordingly.
**
** More of these may be added in the future, such as when nrrd
** supports bricking.  Since nrrd is never going to be in the business
** of manipulating the kind information or supporting kind-specific
** semantics, there can be proliferation of nrrdKinds, provided
** pointless redundancy is avoided.
**
**  There is a relationship between some of these (nrrdKindSpace is a
** specific nrrdKindDomain), but currently there is no effort to
** record this meta-kind information.
**
** Keep in sync:
**   enumsNrrd.c: nrrdKind airEnum
**        axis.c: nrrdKindSize()
**        axis.c: _nrrdKindAltered()
**
** NOTE: The nrrdKindSize() function returns the valid size for these.
**
*/
enum {
  nrrdKindUnknown,
  nrrdKindDomain, /*  1: any image domain */
  nrrdKindSpace,  /*  2: a spatial domain */
  nrrdKindTime,   /*  3: a temporal domain */
  /* -------------------------- end domain kinds */
  /* -------------------------- begin range kinds */
  nrrdKindList,            /*  4: any list of values, non-resample-able */
  nrrdKindPoint,           /*  5: coords of a point */
  nrrdKindVector,          /*  6: coeffs of (contravariant) vector */
  nrrdKindCovariantVector, /*  7: coeffs of covariant vector (eg gradient) */
  nrrdKindNormal,          /*  8: coeffs of unit-length covariant vector */
  /* -------------------------- end arbitrary size kinds */
  /* -------------------------- begin size-specific kinds */
  nrrdKindStub,              /*  9: axis with one sample (a placeholder) */
  nrrdKindScalar,            /* 10: effectively, same as a stub */
  nrrdKindComplex,           /* 11: real and imaginary components */
  nrrdKind2Vector,           /* 12: 2 component vector */
  nrrdKind3Color,            /* 13: ANY 3-component color value */
  nrrdKindRGBColor,          /* 14: RGB, no colorimetry */
  nrrdKindHSVColor,          /* 15: HSV, no colorimetry */
  nrrdKindXYZColor,          /* 16: perceptual primary colors */
  nrrdKind4Color,            /* 17: ANY 4-component color value */
  nrrdKindRGBAColor,         /* 18: RGBA, no colorimetry */
  nrrdKind3Vector,           /* 19: 3-component vector */
  nrrdKind3Gradient,         /* 20: 3-component covariant vector */
  nrrdKind3Normal,           /* 21: 3-component covector, assumed normalized */
  nrrdKind4Vector,           /* 22: 4-component vector */
  nrrdKindQuaternion,        /* 23: (w,x,y,z), not necessarily normalized */
  nrrdKind2DSymMatrix,       /* 24: Mxx Mxy Myy */
  nrrdKind2DMaskedSymMatrix, /* 25: mask Mxx Mxy Myy */
  nrrdKind2DMatrix,          /* 26: Mxx Mxy Myx Myy */
  nrrdKind2DMaskedMatrix,    /* 27: mask Mxx Mxy Myx Myy */
  nrrdKind3DSymMatrix,       /* 28: Mxx Mxy Mxz Myy Myz Mzz */
  nrrdKind3DMaskedSymMatrix, /* 29: mask Mxx Mxy Mxz Myy Myz Mzz */
  nrrdKind3DMatrix,          /* 30: Mxx Mxy Mxz Myx Myy Myz Mzx Mzy Mzz */
  nrrdKind3DMaskedMatrix,    /* 31: mask Mxx Mxy Mxz Myx Myy Myz Mzx Mzy Mzz */
  nrrdKindLast
};
#define NRRD_KIND_MAX 31
/*
******** nrrdAxisInfo enum
**
** the different pieces of per-axis information recorded in a nrrd
*/
/* clang-format off */
enum {
  nrrdAxisInfoUnknown,
  nrrdAxisInfoSize,                   /*  1: number of samples along axis */
  nrrdAxisInfoSpacing,                /*  2: spacing between samples */
  nrrdAxisInfoThickness,              /*  3: thickness of sample region */
  nrrdAxisInfoMin,                    /*  4: min pos. assoc. w/ 1st sample */
  nrrdAxisInfoMax,                    /*  5: max pos. assoc. w/ last sample */
  nrrdAxisInfoSpaceDirection,         /*  6: inter-sample vector in "space" */
  nrrdAxisInfoCenter,                 /*  7: cell vs. node */
  nrrdAxisInfoKind,                   /*  8: from the nrrdKind* enum */
  nrrdAxisInfoLabel,                  /*  9: string describing the axis */
  nrrdAxisInfoUnits,                  /* 10: from the nrrdUnit* enum */
  nrrdAxisInfoLast
};
#define NRRD_AXIS_INFO_MAX               10
#define NRRD_AXIS_INFO_NONE 0
/*
******** nrrdBasicInfo enum
**
** the non-per-axis (or per-array) pieces of information that could
** meaningfully be copied between nrrds (hence the void *data is not
** included).
**
** "Basic" is named after the "basic field specifications" described
** in the NRRD file format definition
*/
enum {
  nrrdBasicInfoUnknown,
  nrrdBasicInfoData,                          /*  1 */
  nrrdBasicInfoType,                          /*  2 */
  nrrdBasicInfoBlocksize,                     /*  3 */
  nrrdBasicInfoDimension,                     /*  4 */
  nrrdBasicInfoContent,                       /*  5 */
  nrrdBasicInfoSampleUnits,                   /*  6 */
  nrrdBasicInfoSpace,                         /*  7 */
  nrrdBasicInfoSpaceDimension,                /*  8 */
  nrrdBasicInfoSpaceUnits,                    /*  9 */
  nrrdBasicInfoSpaceOrigin,                   /* 10 */
  nrrdBasicInfoMeasurementFrame,              /* 11 */
  nrrdBasicInfoOldMin,                        /* 12 */
  nrrdBasicInfoOldMax,                        /* 13 */
  nrrdBasicInfoComments,                      /* 14 */
  nrrdBasicInfoKeyValuePairs,                 /* 15 */
  nrrdBasicInfoLast
};
#define NRRD_BASIC_INFO_MAX                      15
#define NRRD_BASIC_INFO_NONE 0
/* clang-format on */
/*
******** nrrdField enum
**
** the various fields we can parse in a NRRD header
**
** other things which must be kept in sync:
** arraysNrrd.c:
**    _nrrdFieldValidInImage[]
**    _nrrdFieldOnePerAxis[]
**    _nrrdFieldValidInText[]
**    _nrrdFieldRequired[]
** parseNrrd.c:
**    _nrrdReadNrrdParseInfo[]
** enumsNrrd.c:
**    nrrdField definition
** simple.c:
**    _nrrdFieldCheck[]
** write.c:
**    _nrrdFieldInteresting()
**    _nrrdSprintFieldInfo()
** to some extent, in this file:
**    nrrdAxisInfo and nrrdBasicInfo enums
** axis.c (for per-axis info):
**    _nrrdAxisInfoCopy()
** methodsNrrd.c:
**    lots of functions, but you knew that . . .
*/
enum {
  nrrdField_unknown,
  nrrdField_comment,           /*  1 */
  nrrdField_content,           /*  2 */
  nrrdField_number,            /*  3 */
  nrrdField_type,              /*  4 */
  nrrdField_block_size,        /*  5 */
  nrrdField_dimension,         /*  6 */
  nrrdField_space,             /*  7 */
  nrrdField_space_dimension,   /*  8 */
  nrrdField_sizes,             /*  9 ----- begin per-axis ----- */
  nrrdField_spacings,          /* 10 */
  nrrdField_thicknesses,       /* 11 */
  nrrdField_axis_mins,         /* 12 */
  nrrdField_axis_maxs,         /* 13 */
  nrrdField_space_directions,  /* 14 */
  nrrdField_centers,           /* 15 */
  nrrdField_kinds,             /* 16 */
  nrrdField_labels,            /* 17 */
  nrrdField_units,             /* 18 ------ end per-axis ------ */
  nrrdField_min,               /* 19 */
  nrrdField_max,               /* 20 */
  nrrdField_old_min,           /* 21 */
  nrrdField_old_max,           /* 22 */
  nrrdField_endian,            /* 23 */
  nrrdField_encoding,          /* 24 */
  nrrdField_line_skip,         /* 25 */
  nrrdField_byte_skip,         /* 26 */
  nrrdField_keyvalue,          /* 27 */
  nrrdField_sample_units,      /* 28 */
  nrrdField_space_units,       /* 29 */
  nrrdField_space_origin,      /* 30 */
  nrrdField_measurement_frame, /* 31 */
  nrrdField_data_file,         /* 32 */
  nrrdField_last
};
#define NRRD_FIELD_MAX 32
/*
******** nrrdHasNonExist* enum
**
** oh look, I'm violating my rules outline above for how the enum values
** should be ordered.  The reason for this is that its just too bizarro to
** have the logical value of both nrrdHasNonExistFalse and nrrdHasNonExistTrue
** to be (in C) true.  For instance, nrrdHasNonExist() should be able to
** return a value from this enum which also functions in a C expressions as
** the expected boolean value.  If for some reason (outide the action of
** nrrdHasNonExist(), nrrdHasNonExistUnknown is interpreted as true, that's
** probably harmlessly conservative.  Time will tell.
*/
enum {
  nrrdHasNonExistFalse,   /* 0: no non-existent values were seen */
  nrrdHasNonExistTrue,    /* 1: some non-existent values were seen */
  nrrdHasNonExistOnly,    /* 2: NOTHING BUT non-existent values were seen */
  nrrdHasNonExistUnknown, /* 3 */
  nrrdHasNonExistLast
};
#define NRRD_HAS_NON_EXIST_MAX 3
/*
******** nrrdSpace* enum
**
** Identifies the space in which which the origin and direction
** vectors have their coordinates measured.  When a direction is named
** here (like "Left" or "Anterior"), that implies a basis vector that
** points in that direction, along which that coordinate becomes *larger*
** (this is the opposite of MetaIO, for example).
**
** All of these spaces have a well-defined expected dimension, as
** determined by nrrdSpaceDimension(), and setting a nrrd to be in
** such a space, by nrrdSpaceSet(), will automatically set nrrd->spaceDim.
**
** The first six spaces here are PATIENT-ORIENTED spaces, which are
** properly speaking aligned with the patient, and not the scanner
** itself.  But nrrdSpaceScannerXYZ and nrrdSpaceScannerXYZTime are
** DEVICE-ORIENTED spaces, irrespective of the patient, used in a
** previous version of the DICOM standard.  When the two spaces are
** lined up with normal patient orientation in the scanner,
** nrrdSpaceScannerXYZ is the same as nrrdSpaceLeftPosteriorSuperior.
** To quote Part 3 (Information Object Definitions) of the DICOM spec
** (page 275): "If a patient lies parallel to the ground, face-up on
** the table, with his feet-to-head direction same as the
** front-to-back direction of the imaging equipment, the direction of
** the axes of this patient based coordinate system and the equipment
** based coordinate system in previous versions of this Standard will
** coincide."
**
** Keep in sync:
**   enumsNrrd.c: nrrdSpace airEnum
**      simple.c: int nrrdSpaceDimension(int space)
*/
enum {
  nrrdSpaceUnknown,
  nrrdSpaceRightUp,                   /*  1: 2-D, oriented like upper right
                                          Cartesian quadrant, number I */
  nrrdSpaceRightDown,                 /*  2: 2-D, oriented like raster
                                          coordinates */
  nrrdSpaceRightAnteriorSuperior,     /*  3: NIFTI-1 (right-handed) */
  nrrdSpaceLeftAnteriorSuperior,      /*  4: standard Analyze (left-handed) */
  nrrdSpaceLeftPosteriorSuperior,     /*  5: DICOM 3.0 (right-handed) */
  nrrdSpaceRightAnteriorSuperiorTime, /*  6: */
  nrrdSpaceLeftAnteriorSuperiorTime,  /*  7: */
  nrrdSpaceLeftPosteriorSuperiorTime, /*  8: */
  nrrdSpaceScannerXYZ,                /*  9: ACR/NEMA 2.0 (pre-DICOM 3.0) */
  nrrdSpaceScannerXYZTime,            /* 10: */
  nrrdSpace3DRightHanded,             /* 11: */
  nrrdSpace3DLeftHanded,              /* 12: */
  nrrdSpace3DRightHandedTime,         /* 13: */
  nrrdSpace3DLeftHandedTime,          /* 14: */
  nrrdSpaceLast
};
#define NRRD_SPACE_MAX 14
/*
******** nrrdSpacingStatus* enum
**
** a way of describing how spacing information is known or not known for a
** given axis, as determined by nrrdSpacingCalculate
*/
enum {
  nrrdSpacingStatusUnknown,         /* 0: nobody knows,
                                       or invalid axis choice */
  nrrdSpacingStatusNone,            /* 1: neither axis->spacing nor
                                       axis->spaceDirection is set */
  nrrdSpacingStatusScalarNoSpace,   /* 2: axis->spacing set,
                                       w/out space info */
  nrrdSpacingStatusScalarWithSpace, /* 3: axis->spacing set, but there *is*
                                       space info, which means the spacing
                                       does *not* live in the surrounding
                                       space */
  nrrdSpacingStatusDirection,       /* 4: axis->spaceDirection set, and
                                       measured according to surrounding
                                       space */
  nrrdSpacingStatusLast
};
#define NRRD_SPACING_STATUS_MAX 4
/*
******** nrrdOriginStatus* enum
**
** how origin information was or was not computed by nrrdOriginCalculate
*/
enum {
  nrrdOriginStatusUnknown,        /* 0: nobody knows, or invalid parms */
  nrrdOriginStatusDirection,      /* 1: chosen axes have spaceDirections */
  nrrdOriginStatusNoMin,          /* 2: axis->min doesn't exist */
  nrrdOriginStatusNoMaxOrSpacing, /* 3: axis->max or ->spacing doesn't exist */
  nrrdOriginStatusOkay,           /* 4: all is well */
  nrrdOriginStatusLast
};
/* ---- BEGIN non-NrrdIO */
/*
******** nrrdFormatPNGsRGBIntent* enum
**
** indicates values of PNG_sRGB_INTENT_, for the sRGB chunk of PNG,
** or indicates not knowing it. This is unusual because the unknown
** value is -1, not 0, and the #define is for NUM, not MAX. The 0,1,2,3
** values of the intents copy how they're represented in ICC profiles,
** which apparently png.h copies in turn; see
** http://www.libpng.org/pub/png/book/chapter10.html
*/
enum {
  nrrdFormatPNGsRGBIntentUnknown = -1, /* -1: nobody knows */
  nrrdFormatPNGsRGBIntentPerceptual,   /* 0: PNG_sRGB_INTENT_PERCEPTUAL */
  nrrdFormatPNGsRGBIntentRelative,     /* 1: PNG_sRGB_INTENT_RELATIVE */
  nrrdFormatPNGsRGBIntentSaturation,   /* 2: PNG_sRGB_INTENT_SATURATION */
  nrrdFormatPNGsRGBIntentAbsolute,     /* 3: PNG_sRGB_INTENT_ABSOLUTE */
  nrrdFormatPNGsRGBIntentNone,         /* 4: do not indicate intent */
  nrrdFormatPNGsRGBIntentLast
};
#define NRRD_FORMAT_PNG_SRGB_INTENT_NUM 5
/*
******** nrrdOrientationHave* enum
**
** ways of describing how much information about the orientation
** we have
*/
enum {
  nrrdOrientationHaveUnknown,          /* 0 */
  nrrdOrientationHaveNothing,          /* 1 */
  nrrdOrientationHaveSpacing,          /* 2 */
  nrrdOrientationHaveMinSpacing,       /* 3 */
  nrrdOrientationHaveMinMax,           /* 4 */
  nrrdOrientationHaveDirections,       /* 5 */
  nrrdOrientationHaveOriginDirections, /* 6 */
  nrrdOrientationHaveLast
};
#define NRRD_ORIENTATION_HAVE_MAX 6
/*
******** nrrdMeasure enum
**
** ways to "measure" some portion of the array
** NEEDS TO BE IN SYNC WITH:
** - nrrdMeasure airEnum in enumsNrrd.c
** - nrrdMeasureLine function array in measure.c
*/
enum {
  nrrdMeasureUnknown,
  nrrdMeasureMin,            /* 1: smallest value */
  nrrdMeasureMax,            /* 2: biggest value */
  nrrdMeasureMean,           /* 3: average of values */
  nrrdMeasureMedian,         /* 4: value at 50th percentile */
  nrrdMeasureMode,           /* 5: most common value */
  nrrdMeasureProduct,        /* 6: product of all values */
  nrrdMeasureSum,            /* 7: sum of all values */
  nrrdMeasureL1,             /* 8 */
  nrrdMeasureL2,             /* 9 */
  nrrdMeasureL4,             /* 10 */
  nrrdMeasureNormalizedL2,   /* 11 */
  nrrdMeasureRootMeanSquare, /* 12 */
  nrrdMeasureLinf,           /* 13 */
  nrrdMeasureVariance,       /* 14 */
  nrrdMeasureSD,             /* 15: standard deviation */
  nrrdMeasureCoV,            /* 16: coefficient of variation */
  nrrdMeasureSkew,           /* 17: skew */
  nrrdMeasureLineSlope,      /* 18: slope of line of best fit */
  nrrdMeasureLineIntercept,  /* 19: y-intercept of line of best fit */
  nrrdMeasureLineError,      /* 20: error of line fitting */
  /*
  ** the nrrduMeasureHisto* measures interpret the array as a
  ** histogram of some implied value distribution
  */
  nrrdMeasureHistoMin,      /* 21 */
  nrrdMeasureHistoMax,      /* 22 */
  nrrdMeasureHistoMean,     /* 23 */
  nrrdMeasureHistoMedian,   /* 24 */
  nrrdMeasureHistoMode,     /* 25 */
  nrrdMeasureHistoProduct,  /* 26 */
  nrrdMeasureHistoSum,      /* 27 */
  nrrdMeasureHistoL2,       /* 28 */
  nrrdMeasureHistoVariance, /* 29 */
  nrrdMeasureHistoSD,       /* 30 */
  nrrdMeasureLast
};
#define NRRD_MEASURE_MAX 30
/*
******** nrrdBlind8BitRange
**
** whether or not to blindly say that the range of 8-bit data is
** [0,255] (uchar) or [SCHAR_MIN,SCHAR_MAX] (signed char)
*/
enum {
  nrrdBlind8BitRangeUnknown, /* 0 */
  nrrdBlind8BitRangeTrue,    /* 1: blindly use the widest extrema (e.g.,
                                [0-255] for uchar, regardless of what's
                                really present in the data values */
  nrrdBlind8BitRangeFalse,   /* 2: use the exact value range in the data */
  nrrdBlind8BitRangeState,   /* 3: defer to nrrdStateBlind8BitMinMax */
  nrrdBlind8BitRangeLast
};
#define NRRD_BLIND_8BIT_RANGE_MAX 3
/*
******** nrrdUnaryOp enum
**
** for unary operations on nrrds
*/
enum {
  nrrdUnaryOpUnknown,
  nrrdUnaryOpNegative,   /*  1 */
  nrrdUnaryOpReciprocal, /*  2 */
  nrrdUnaryOpSin,        /*  3 */
  nrrdUnaryOpCos,        /*  4 */
  nrrdUnaryOpTan,        /*  5 */
  nrrdUnaryOpAsin,       /*  6 */
  nrrdUnaryOpAcos,       /*  7 */
  nrrdUnaryOpAtan,       /*  8 */
  nrrdUnaryOpExp,        /*  9 */
  nrrdUnaryOpLog,        /* 10 */
  nrrdUnaryOpLog2,       /* 11 */
  nrrdUnaryOpLog10,      /* 12 */
  nrrdUnaryOpLog1p,      /* 13 */
  nrrdUnaryOpExpm1,      /* 14 */
  nrrdUnaryOpSqrt,       /* 15 */
  nrrdUnaryOpCbrt,       /* 16 */
  nrrdUnaryOpErf,        /* 17 */
  nrrdUnaryOpNerf,       /* 18 */
  nrrdUnaryOpCeil,       /* 19 */
  nrrdUnaryOpFloor,      /* 20 */
  nrrdUnaryOpRoundUp,    /* 21 */
  nrrdUnaryOpRoundDown,  /* 22 */
  nrrdUnaryOpAbs,        /* 23 */
  nrrdUnaryOpSgn,        /* 24 */
  nrrdUnaryOpExists,     /* 25 */
  nrrdUnaryOpRand,       /* 26 */
  nrrdUnaryOpNormalRand, /* 27 */
  nrrdUnaryOpIf,         /* 28 */
  nrrdUnaryOpZero,       /* 29 */
  nrrdUnaryOpOne,        /* 30 */
  nrrdUnaryOpTauOfSigma, /* 31 */
  nrrdUnaryOpSigmaOfTau, /* 32 */
  nrrdUnaryOpLast
};
#define NRRD_UNARY_OP_MAX 32
/*
******** nrrdBinaryOp enum
**
** for binary operations on nrrds
*/
enum {
  nrrdBinaryOpUnknown,
  nrrdBinaryOpAdd,                /*  1 */
  nrrdBinaryOpSubtract,           /*  2 */
  nrrdBinaryOpMultiply,           /*  3 */
  nrrdBinaryOpDivide,             /*  4 */
  nrrdBinaryOpPow,                /*  5 */
  nrrdBinaryOpSgnPow,             /*  6 */
  nrrdBinaryOpFlippedSgnPow,      /*  7 */
  nrrdBinaryOpMod,                /*  8 */
  nrrdBinaryOpFmod,               /*  9 */
  nrrdBinaryOpAtan2,              /* 10 */
  nrrdBinaryOpMin,                /* 11 */
  nrrdBinaryOpMax,                /* 12 */
  nrrdBinaryOpLT,                 /* 13 */
  nrrdBinaryOpLTE,                /* 14 */
  nrrdBinaryOpGT,                 /* 15 */
  nrrdBinaryOpGTE,                /* 16 */
  nrrdBinaryOpCompare,            /* 17 */
  nrrdBinaryOpEqual,              /* 18 */
  nrrdBinaryOpNotEqual,           /* 19 */
  nrrdBinaryOpExists,             /* 20 */
  nrrdBinaryOpIf,                 /* 21 */
  nrrdBinaryOpNormalRandScaleAdd, /* 22 */
  nrrdBinaryOpRicianRand,         /* 23 */
  /* Adding these is a bit of a hack- whether or not to clamp to the
     representational range of an output integer type should really be an
     argument to the arithmetic functions, but this allows it be done
     without any API change */
  nrrdBinaryOpAddClamp,      /* 24 */
  nrrdBinaryOpSubtractClamp, /* 25 */
  nrrdBinaryOpMultiplyClamp, /* 26 */
  nrrdBinaryOpULPDistance,   /* 27 */
  nrrdBinaryOpLast
};
#define NRRD_BINARY_OP_MAX 27
/*
******** nrrdTernaryOp
**
** for ternary operations on nrrds
*/
enum {
  nrrdTernaryOpUnknown,
  nrrdTernaryOpAdd,       /*  1 */
  nrrdTernaryOpMultiply,  /*  2 */
  nrrdTernaryOpMin,       /*  3 */
  nrrdTernaryOpMinSmooth, /*  4 */
  nrrdTernaryOpMax,       /*  5 */
  nrrdTernaryOpMaxSmooth, /*  6 */
  nrrdTernaryOpLTSmooth,  /*  7 */
  nrrdTernaryOpGTSmooth,  /*  8 */
  nrrdTernaryOpClamp,     /*  9 */
  nrrdTernaryOpIfElse,    /* 10 */
  nrrdTernaryOpLerp,      /* 11 */
  nrrdTernaryOpExists,    /* 12 */
  nrrdTernaryOpInOpen,    /* 13 */
  nrrdTernaryOpInClosed,  /* 14 */
  nrrdTernaryOpGaussian,  /* 15 */
  nrrdTernaryOpRician,    /* 16 */
  nrrdTernaryOpLast
};
#define NRRD_TERNARY_OP_MAX 16
/*
******** nrrdFFTWPlanRigor
**
** Different levels of rigor in FFTW planning
*/
enum {
  nrrdFFTWPlanRigorUnknown,
  nrrdFFTWPlanRigorEstimate,   /* 1 */
  nrrdFFTWPlanRigorMeasure,    /* 2 */
  nrrdFFTWPlanRigorPatient,    /* 3 */
  nrrdFFTWPlanRigorExhaustive, /* 4 */
  nrrdFFTWPlanRigorLast
};
#define NRRD_FFTW_PLAN_RIGOR_MAX 4
/*
******** nrrdResampleNonExistent
**
** different ways that nrrdResample should handle non-existent values
*/
enum {
  nrrdResampleNonExistentUnknown,
  nrrdResampleNonExistentNoop,        /* 1 */
  nrrdResampleNonExistentRenormalize, /* 2 */
  nrrdResampleNonExistentWeight,      /* 3 */
  nrrdResampleNonExistentLast
};
#define NRRD_RESAMPLE_NON_EXISTENT_MAX 3
/*
******** nrrdMetaDataCanonicalVersion
**
** different strategies for putting meta-data into a canonical form
*/
enum {
  nrrdMetaDataCanonicalVersionUnknown,
  nrrdMetaDataCanonicalVersionAlpha, /* 1 */
  nrrdMetaDataCanonicalVersionLast
};
#define NRRD_META_DATA_CANONICAL_VERSION_MAX 1
/* ---- END non-NrrdIO */


/* =========== nrrdDefines.h =========== */
/*
  Teem: Tools to process and visualize scientific data and images
  Copyright (C) 2009--2023  University of Chicago
  Copyright (C) 2005--2008  Gordon Kindlmann
  Copyright (C) 1998--2004  University of Utah
  This library is free software; you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License (LGPL) as published by the Free Software
  Foundation; either version 2.1 of the License, or (at your option) any later version.
  The terms of redistributing and/or modifying this software also include exceptions to
  the LGPL that facilitate static linking.
  This library is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public License along with
  this library; if not, write to Free Software Foundation, Inc., 51 Franklin Street,
  Fifth Floor, Boston, MA 02110-1301 USA
*/
/* feel free to set these to higher values and recompile */
#define NRRD_DIM_MAX       16
/*                             Max array dimension (nrrd->dim) */
#define NRRD_SPACE_DIM_MAX 8
/*                             Max dimension of "space" around array
                               (nrrd->spaceDim) */
/* HEY: should this be renamed -> MAXNUM ? Would be more consistent
   with other Teem pound-define names */
#define NRRD_KERNEL_PARMS_NUM 8
/*                              max # arguments to a kernel- this is weird: it
                                isn't the max of any of the NrrdKernels defined
                                by the nrrd library (that is more like 3), but
                                is the max number of parms of any NrrdKernel
                                used by anyone using Teem, such as in gage.
                                Enforcing one global max simplifies
                                implementation. */
/*
** For the 64-bit integer types (not standard except in C99), we used
** to try to use the names for the _MIN and _MAX values which are used
** in C99 (as well as gcc) such as LLONG_MAX, or those used on SGI
** such as LONGLONG_MAX.  However, since the tests (in nrrdSanity)
** were re-written to detect overflow based on manipulation of
** specific values, we might as well also define the _MIN and _MAX in
** terms of explicit values (which agree with those defined by C99).
*/
/*
** Chances are, you shouldn't mess with these
*/
/* ---- BEGIN non-NrrdIO */
/* suffix string that indicates percentile-based min/max */
/* ---- END non-NrrdIO */
#define NRRD_FILENAME_INCR    32
#define NRRD_COMMENT_INCR     16
#define NRRD_KEYVALUE_INCR    32
/*                                   this is designed to be robust against the
                                     mungling that xv does, but no promises for
                                     any other image programs */
/*                                   this is the key used for getting nrrd
                                     fields into/out of png comments */
/*                                   this is the key used for getting nrrd
                                     comments into/out of png comments */
/*                                   how to represent something unknown in a
                                     field of the nrrd header, when it being
                                     unknown is not an error */
/*                                   like NRRD_UNKNOWN, but with an air of
                                     certainty */


/* =========== nrrd.h =========== */
/*
  Teem: Tools to process and visualize scientific data and images
  Copyright (C) 2009--2023  University of Chicago
  Copyright (C) 2005--2008  Gordon Kindlmann
  Copyright (C) 1998--2004  University of Utah
  This library is free software; you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License (LGPL) as published by the Free Software
  Foundation; either version 2.1 of the License, or (at your option) any later version.
  The terms of redistributing and/or modifying this software also include exceptions to
  the LGPL that facilitate static linking.
  This library is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public License along with
  this library; if not, write to Free Software Foundation, Inc., 51 Franklin Street,
  Fifth Floor, Boston, MA 02110-1301 USA
*/
/* ---- BEGIN non-NrrdIO */
/* ---- END non-NrrdIO */
/*
******** NrrdAxisInfo struct
**
** all the information which can sensibly be associated with
** one axis of a nrrd.  The only member which MUST be explicitly
** set to something meaningful is "size".
**
** If an axis lies conceptually along some direction in an enclosing
** space of dimension nrrd->spaceDim, then the first nrrd->spaceDim
** entries of spaceDirection[] must be non-NaN, and min, max, spacing,
** and units must NOT be set;  thickness, center, and label can still
** be used.  The mutual exclusion between axis-aligned and general
** direction information is enforced per-axis, not per-array.
**
** The min and max values give the range of positions "represented"
** by the samples along this axis.  In node-centering, "min" IS the
** position at the lowest index.  In cell-centering, the position at
** the lowest index is between min and max (a touch bigger than min,
** assuming min < max).
**
** There needs to be a one-to-one correspondence between these variables
** and the nrrdAxisInfo* enum (nrrdEnums.h), the per-axis header fields
** (see nrrdField* enum in nrrdEnums.h), and the various methods in axis.c
*/
typedef struct {
  size_t size;
  /*                number of elements along each axis */
  double spacing;
  /*                if non-NaN, distance between samples */
  double thickness;
  /*                if non-NaN, nominal thickness of region represented by one
                    sample along the axis. No semantics relative to spacing are
                    assumed or imposed, and unlike spacing, there is no
                    sensible way to alter thickness- it is either copied (as
                    with cropping and slicing) or set to NaN (when
                    resampled). */
  double min, max;
  /*                if non-NaN, range of positions spanned by the samples on
                    this axis.  Obviously, one can set "spacing" to something
                    incompatible with min and max: the idea is that only one
                    (min and max, or spacing) should be taken to be significant
                    at any time. */
  double spaceDirection[NRRD_SPACE_DIM_MAX];
  /*                the vector, in "space" (as described by nrrd->space and/or
                    nrrd->spaceDim), from one sample to the next sample along
                    this axis.  It is the column vector of the transform from
                    index space to "space" space */
  int center;
  /*                cell vs. node centering (value should be one of
                    nrrdCenter{Unknown,Node,Cell} */
  int kind;
  /*                what kind of information is along this axis (from the
                    nrrdKind* enum) */
  char *label;
  /*                short info string for each axis */
  char *units;
  /*                string identifying the unit */
} NrrdAxisInfo;
/*
******** Nrrd struct
**
** The struct used to wrap around the raw data array
*/
typedef struct {
  /*
  ** NECESSARY information describing the main array.  This is
  ** generally set at the same time that either the nrrd is created,
  ** or at the time that the nrrd is wrapped around an existing array
  */
  void *data;
  /*                               the data in memory */
  int type;
  /*                               a value from the nrrdType enum */
  unsigned int dim;
  /*                               the dimension (rank) of the array */
  /*
  ** All per-axis specific information
  */
  NrrdAxisInfo axis[NRRD_DIM_MAX];
  /*                               axis[0] is the fastest axis in the scan-
                                   line ordering, the one who's coordinates
                                   change the fastest as the elements are
                                   accessed in the order in which they appear
                                   in memory */
  /*
  ** Optional information descriptive of whole array, some of which is
  ** meaningfuly for only some uses of a nrrd
  */
  char *content;
  /*                               brief account of what this data is */
  char *sampleUnits;
  /*                               units of measurement of the values stored in
                                   the array itself (not the array axes and not
                                   space coordinates).  The logical name might
                                   be "dataUnits", but that's perhaps
                                   ambiguous.  Note that these units may apply
                                   to non-scalar kinds (e.g. coefficients of a
                                   vector have the same units) */
  int space;
  /*                               from nrrdSpace* enum, and often implies the
                                   value of spaceDim */
  unsigned int spaceDim;
  /*                               if non-zero, the dimension of the space in
                                   which the regular sampling grid conceptually
                                   lies.  This is a separate variable because
                                   this dimension can be different than the
                                   array dimension.  The non-zero-ness of this
                                   value is in fact the primary indicator that
                                   space and orientation information is set.
                                   This identifies the number of entries in
                                   "origin" and the per-axis "direction"
                                   vectors that are taken as meaningful */
  char *spaceUnits[NRRD_SPACE_DIM_MAX];
  /*                               units for coordinates of space */
  double spaceOrigin[NRRD_SPACE_DIM_MAX];
  /*                               the location of the center the first (lowest
                                   memory address) array sample, regardless of
                                   node-vs-cell centering */
  double measurementFrame[NRRD_SPACE_DIM_MAX][NRRD_SPACE_DIM_MAX];
  /*                               if spaceDim is non-zero, this may store a
                                   spaceDim-by-spaceDim matrix which transforms
                                   vector/matrix coefficients in the
                                   "measurement frame" to those in the world
                                   space described by spaceDim (and hopefully
                                   space).  Coeff [i][j] is *column* i & *row*
                                   j, which is probably the *transpose* of what
                                   you expect.  There are no semantics linking
                                   this to the "kind" of any axis, for a
                                   variety of reasons */
  size_t blockSize;
  /*                               for nrrdTypeBlock, block byte size */
  double oldMin, oldMax;
  /*                               if non-NaN, and if nrrd is of integral type,
                                   extremal values for the array BEFORE it was
                                   quantized */
  void *ptr;
  /*                               never read or set by nrrd; use/abuse as you
                                   see fit */
  /*
  ** Comments.  Read from, and written to, header.
  ** The comment array "cmt" is NOT NULL-terminated.
  ** The number of comments is cmtArr->len.
  */
  char **cmt;
  airArray *cmtArr;
  /*
  ** Key-value pairs.
  */
  char **kvp;
  airArray *kvpArr;
} Nrrd;
struct NrrdIoState_t;
struct NrrdEncoding_t;
/*
******** NrrdFormat
**
** All information and behavior relevent to one datafile format
*/
typedef struct {
  char name[AIR_STRLEN_SMALL + 1]; /* short identifying string */
  int isImage, /* this format is intended solely for "2D" images, which
                  controls the invocation of nrrdAxesInsert()
                  if nrrdStateGrayscaleImage3D */
    readable,  /* we can read as well as write this format */
    usesDIO;   /* this format can use Direct IO */
  /* tests if this format is currently available in this build */
  int (*available)(void);
  /* (for writing) returns non-zero if a given filename could likely be
     represented by this format */
  int (*nameLooksLike)(const char *filename);
  /* (for writing) returns non-zero if a given nrrd/encoding pair will fit
     in this format */
  int (*fitsInto)(const Nrrd *nrrd, const struct NrrdEncoding_t *encoding, int useBiff);
  /* (for reading) returns non-zero if what has been read in so far
     is recognized as the beginning of this format */
  int (*contentStartsLike)(struct NrrdIoState_t *nio);
  /* reader and writer. Both are expected to use biff */
  int (*read)(FILE *file, Nrrd *nrrd, struct NrrdIoState_t *nio);
  int (*write)(FILE *file, const Nrrd *nrrd, struct NrrdIoState_t *nio);
} NrrdFormat;
/*
******** NrrdEncoding
**
** All information and behavior relevent to one way of encoding data
**
** The data readers are responsible for memory allocation.
** This is necessitated by the memory restrictions of direct I/O
*/
typedef struct NrrdEncoding_t {
  char name[AIR_STRLEN_SMALL + 1], /* short identifying string */
    suffix[AIR_STRLEN_SMALL + 1];  /* customary filename suffix */
  int endianMatters, isCompression;
  int (*available)(void);
  /* The "data" and "elementNum" values have to be passed explicitly
     to read/wrote because they will be different from nrrd->data and
     nrrdElementNumber(nrrd) in the case of multiple data files.  You
     might think that the only other thing required to be passed is
     nrrdElementSize(nrrd), but no, it is in fact best to pass the
     whole Nrrd, instead of just certain attributes.  The stupid details:
             nrrd->dim: needed to know whether to put one value per line
                        in case of 1-D nrrdEncodingAscii
    nrrd->axis[0].size: need for proper formatting of nrrdEncodingAscii
            nrrd->type: needed for nrrdEncodingAscii, since its action is
                        entirely parameterized by type
       nrrd->blockSize: needed for nrrdElementSize in case of nrrdTypeBlock
    Both read and write functions are expected to use biff. */
  int (*read)(FILE *file, void *data, size_t elementNum, Nrrd *nrrd,
              struct NrrdIoState_t *nio);
  int (*write)(FILE *file, const void *data, size_t elementNum, const Nrrd *nrrd,
               struct NrrdIoState_t *nio);
} NrrdEncoding;
/*
******** NrrdIoState struct
**
** Everything relating to how the nrrd is read and written.
** Multiple parameters for writing are set here (like format, encoding,
** zlib parameters).  Also, this is the place where those few parameters
** of reading are stored (like skipData and keepNrrdDataFileOpen).  Also,
** after the nrrd has been read, it is a potentially useful record of what
** it took to read it in.
*/
typedef struct NrrdIoState_t {
  char *path,                   /* allows us to remember the directory
                                   from whence this nrrd was "load"ed, or
                                   to whence this nrrd is "save"ed, MINUS the
                                   trailing "/", so as to facilitate games with
                                   header-relative data files */
    *base,                      /* when "save"ing a nrrd into separate
                                   header and data, the name of the header
                                   file (e.g. "output.nhdr") MINUS the ".nhdr".
                                   This is massaged to produce a header-
                                   relative data filename.  */
    *line,                      /* buffer for saving one line from file */
    *dataFNFormat,              /* if non-NULL, the format string (containing
                                   something like "%d" as a substring) to be
                                   used to identify multiple detached datafiles.
                                   NB: This is "format" in the sense of a printf-
                                   style format string, not in the sense of a
                                   file format.  This may need header-relative
                                   path processing. */
    **dataFN,                   /* ON READ + WRITE: array of data filenames. These
                                   are not passed directly to fopen, they may need
                                   header-relative path processing. Like the
                                   cmtArr in the Nrrd, this array is not NULL-
                                   terminated */
    *headerStringWrite;         /* ON WRITE: string from to which the header can
                                   be written.  On write, it is assumed allocated
                                   for as long as it needs to be (probably via a
                                   first pass with learningHeaderStrlen). NOTE:
                                   It is the non-NULL-ity of this which signifies
                                   the intent to do string-based writing */
  const char *headerStringRead; /* ON READ: like headerStringWrite, but for
                                   reading the header from.  NOTE: It is the
                                   non-NULL-ity of this which signifies the
                                   intent to do string-based reading */
  airArray *dataFNArr;          /* for managing the above */
  FILE *headerFile,         /* if non-NULL, the file from which the NRRD
                               header is being read */
    *dataFile;              /* this used to be a central part of how the
                               I/O code worked, but now it is simply the
                               place to store the dataFile in the case of
                               keepNrrdDataFileOpen */
  unsigned int dataFileDim, /* The dimension of the data in each data file.
                               Together with dataFNArr->len, this determines
                               how many bytes should be in each data file */
    lineLen,                /* allocated size of line, including the
                               last character for \0 */
    charsPerLine,           /* when writing ASCII data in which we
                               intend only to write a huge long list
                               of numbers whose text formatting
                               implies nothing, then how many
                               characters do we limit ourselves to per
                               line */
    valsPerLine,            /* when writing ASCII data in which we DO
                               intend to sigify (or at least hint at)
                               something with the formatting, then
                               what is the max number of values to
                               write on a line */
    lineSkip,               /* if dataFile non-NULL, the number of
                               lines in dataFile that should be
                               skipped over (so as to bypass another
                               form of ASCII header preceeding raw
                               data) */
    headerStrlen,           /* ON WRITE, for NRRDs, if learningHeaderStrlen,
                               the learned strlen of the header so far */
    headerStrpos;           /* ON READ, for NRRDs, if headerStringRead is
                               non-NULL, the current location of reading
                               in the header */
  long int byteSkip;        /* exactly like lineSkip, but bytes
                               instead of lines.  First the lines are
                               skipped, then the bytes */
  long int *dataFSkip;      /* skip per-data-file line from a NRRD0006 "data
                               file: SKIPLIST" specification; THIS OVERRIDES
                               the single byteSkip above. The non-NULL-ity of
                               this indicates there is a per-file byte skip.
                               Line skip still precedes per-file byte skip. */
  airArray *dataFSkipArr;   /* for managing the above */
  /* Note that the NRRD0004 and NRRD0005 file formats indicate that a numbered
     sequence of data filenames should be indexed via a "%d" format
     specification, and that the format doc says nothing about the "min" and
     "max" fields of "data file" being only positive.  So the following three
     dataFN* fields are appropriately (signed) ints, even if all normal usage
     could also be represented with unsigned ints.  Nonetheless, the return
     from _nrrdDataFNNumber(), which gives the total number of file names, is
     still appropriately an unsigned int. This may be revisited if the file
     format itself is adjusted. */
  int dataFNMin, /* used with dataFNFormat to identify .. */
    dataFNMax,   /* .. all the multiple detached datafiles */
    dataFNStep;  /* how to step from max to min */
  /* On the other hand, dataFNIndex ranges from 0 to (#datafiles-1),
     and not dataFNMin to dataFNMax, so it really should be unsigned */
  unsigned int dataFNIndex;   /* which of the data files are being read */
  int pos,                    /* line[pos] is beginning of stuff which
                                 still has yet to be parsed */
    endian,                   /* endian-ness of the data in file, for
                                 those encoding/type combinations for
                                 which it matters (from nrrdEndian) */
    seen[NRRD_FIELD_MAX + 1], /* for error checking in header parsing */
    detachedHeader,           /* ON WRITE: request for file (NRRD format only)
                                 to be split into distinct header and data.
                                 This only has an effect if detaching the header
                                 is not already necessary, as it is with multiple
                                 data files */
    bareText,                 /* when writing a plain text file, is there any
                                 effort made to record the nrrd struct
                                 info in the text file */
    moreThanFloatInText,      /* when writing a plain text file, instead of the
                                 usual behavior of silently converting to float,
                                 explicitly record the type, and also ensure
                                 that the ascii encoding is lossless */
    skipData,                 /* if non-zero (all formats):
                                 ON READ: don't allocate memory for, and don't
                                 read in, the data portion of the file (but we
                                 do verify that for nrrds, detached datafiles
                                 can be opened).  Note: Does NOT imply
                                 keepNrrdDataFileOpen.  Warning: resulting
                                 nrrd struct will have "data" pointer NULL.
                                 ON WRITE: don't write data portion of file
                                 (for nrrds, don't even try to open detached
                                 datafiles).  Warning: can result in broken
                                 noncomformant files.
                                 (be careful with this) */
    skipFormatURL,            /* if non-zero for NRRD format ON WRITE:
                                 skip the comment lines that document where
                                 to find the NRRD file format specs */
    keepNrrdDataFileOpen,     /* ON READ: when there is only a single dataFile,
                                 don't close nio->dataFile when
                                 you otherwise would, when reading the
                                 nrrd format. Probably used in conjunction with
                                 skipData.  (currently for "unu data")
                                 ON WRITE: no semantics */
    zlibLevel,                /* zlib compression level (0-9, -1 for
                                 default[6], 0 for no compression). */
    zlibStrategy,             /* zlib compression strategy, can be one
                                 of the nrrdZlibStrategy enums, default is
                                 nrrdZlibStrategyDefault. */
    bzip2BlockSize,           /* block size used for compression,
                                 roughly equivalent to better but slower
                                 (1-9, -1 for default[9]). */
    /* ---- BEGIN non-NrrdIO */
    /* seems odd to have contents of NrrdIoState differ between full Teem
       and NrrdIO, but these fields can't be meaningfully set or read if
       the nrrdFormatPNGsRGBIntent is not available */
    PNGsRGBIntentKnown, /* ON READ+WRITE: for array being read from or
                           written to PNG, we know an sRGB intent */
    PNGsRGBIntent,      /* ON READ+WRITE: iff sRGBIntentKnown, the intent
                           itself, from nrrdFormatPNGsRGBIntent* enum */
    /* ---- END non-NrrdIO */
    learningHeaderStrlen; /* ON WRITE, for nrrds, learn and save the total
                             length of header into headerStrlen. This is
                             used to allocate a buffer for header */
  void *oldData;          /* ON READ: if non-NULL, pointer to space that
                             has already been allocated for oldDataSize */
  size_t oldDataSize;     /* ON READ: size of mem pointed to by oldData */
  /* The format and encoding.  These are initialized to nrrdFormatUnknown
     and nrrdEncodingUnknown, respectively. USE THESE VALUES for
     any kind of initialization or flagging; DO NOT USE NULL */
  const NrrdFormat *format;
  const NrrdEncoding *encoding;
} NrrdIoState;
/* ---- BEGIN non-NrrdIO */
/*
******** NrrdRange
**
** information about a range of values, used as both a description
** of an existing nrrd, or as input to functions like nrrdQuantize
** (in which case the given min,max may not correspond to the actual
** min,max of the nrrd in question).
**
** This information has been removed from the Nrrd struct (as of Teem1.6)
** and put into this separate entity because:
** 1) when intended to be descriptive of a nrrd, it can't be guaranteed
** to be true across nrrd calls
** 2) when used as input parameters (e.g. to nrrdQuantize), its not
** data-flow friendly (you can't modify input)
*/
typedef struct {
  double min, max; /* if non-NaN, nominally: extremal values for array, but
                      practically: the min and max values to use for nrrd
                      calls for which a min and max values are used */
  int hasNonExist; /* from the nrrdHasNonExist* enum values */
} NrrdRange;
/*
******** NrrdKernel struct
**
** these are essentially the methods of the various kernels implemented.
**
** Nrrd's use of this sort of kernel always assumes support symmetric
** around zero, but does not assume anything about even- or oddness
**
** It is a strong but very simplifying assumption that the parameter
** array ("parm") is always type double.  There is essentially no
** value in allowing flexibility between float and double, and much
** Teem code assumes that it will always be type double.
*/
typedef struct {
  /* terse string representation of kernel function, irrespective of
     the parameter vector */
  char name[AIR_STRLEN_SMALL + 1];
  /* number of parameters needed (# elements in parm[] used) */
  unsigned int numParm; /* HEY: should be "parmNum" in standard convention */
  /* smallest x (x > 0) such that k(y) = 0 for all y > x, y < -x */
  double (*support)(const double *parm);
  /* integral of kernel from -support to +support */
  double (*integral)(const double *parm);
  /* evaluate once, single precision */
  float (*eval1_f)(float x, const double *parm);
  /* evaluate N times, single precision */
  void (*evalN_f)(float *f, const float *x, size_t N, const double *parm);
  /* evaluate once, double precision */
  double (*eval1_d)(double x, const double *parm);
  /* evaluate N times, double precision */
  void (*evalN_d)(double *f, const double *x, size_t N, const double *parm);
} NrrdKernel;
/*
******** NrrdKernelSpec struct
**
** for those times when it makes most sense to directly associate a
** NrrdKernel with its parameter vector (that is, a full kernel
** "spec"ification), basically: using hest.
*/
typedef struct {
  const NrrdKernel *kernel;
  double parm[NRRD_KERNEL_PARMS_NUM];
} NrrdKernelSpec;
/*
******** NrrdResampleInfo struct
**
** a struct to contain the many parameters needed for nrrdSpatialResample()
*/
typedef struct {
  const NrrdKernel
    *kernel[NRRD_DIM_MAX];      /* which kernel to use on each axis; use NULL to
                                   say no resampling whatsoever on this axis */
  size_t samples[NRRD_DIM_MAX]; /* number of samples per axis */
  double parm[NRRD_DIM_MAX][NRRD_KERNEL_PARMS_NUM], /* kernel arguments */
    min[NRRD_DIM_MAX],
    max[NRRD_DIM_MAX]; /* min[i] and max[i] are the range, in WORLD space,
                          along which to resample axis i.  axis mins and
                          maxs are required on resampled axes. */
  int boundary,        /* value from the nrrdBoundary enum */
    type,              /* desired type of output, use nrrdTypeUnknown for
                          "same as input" */
    renormalize,       /* when downsampling with a kernel with non-zero
                          integral, should we renormalize the weights to
                          match the kernel integral so as to remove
                          annoying ripple */
    round,             /* when copying from the last intermediate (floating
                          point) result to the output nrrd, for integer
                          outputs, do we round to the nearest integer
                          first, before clamping and assigning.  Enabling
                          this fixed the mystery of downsampling large
                          constant regions of 255 (uchar), and ending up
                          with 254 */
    clamp,             /* when copying from the last intermediate
                          (floating point) result to the output nrrd,
                          should we clamp the values to the range of
                          values for the output type, a concern only for
                          integer outputs */
    cheap;             /* when *downsampling* (reducing the number of
                          samples), don't bother expanding the kernel to
                          achieve filtering in the old index space; with
                          nrrdKernelBox this can lead to subsampling by
                          picking using every other value */
  double padValue;     /* if padding, what value to pad with */
} NrrdResampleInfo;
/*
******** NrrdResampleAxis struct
**
** specific to one pass (one pass per axis) of resampling process
*/
typedef struct {
  /* ----------- input ---------- */
  const NrrdKernel *kernel;            /* which kernel to use on this axis; use NULL to
                                          say no resampling whatsoever on this axis */
  double kparm[NRRD_KERNEL_PARMS_NUM]; /* kernel arguments */
  double min, max;                     /* range in INDEX space of resampling */
  size_t samples;                      /* number output samples on this axis (sizeOut) */
  int overrideCenter;                  /* possible explicit setting of centering */
  /* ----------- internal ---------- */
  int center;               /* centering for this axis */
  size_t sizeIn,            /* number input samples on this axis */
    sizePerm[NRRD_DIM_MAX]; /* permutation of axis sizes for this pass */
  unsigned int axIdx,       /* what axis are we (redundant with other info) */
    passIdx,                /* exactly which pass are we on */
    axisPerm[NRRD_DIM_MAX]; /* permutation of axis indices for this pass */
  double ratio;             /* > 1: upsampling; < 1: downsampling */
  Nrrd *nrsmp,              /* intermediate resampling result; input to
                               this pass */
    *nline,                 /* input scanline buffer (includes extra sample
                               at end for storing pad value) */
    *nindex,                /* row of input indices for each output sample */
    *nweight;               /* row of input weights for each output sample */
} NrrdResampleAxis;
/*
******** NrrdResampleContext struct
**
** contains the parameters and state associated with resampling,
** geared towards quickly resampling multiple different nrrds with the
** same shape.
*/
typedef struct {
  /* ----------- input ---------- */
  const Nrrd *nin; /* the nrrd being resampled */
  int verbose,     /* blah blah blah */
    boundary,      /* value from the nrrdBoundary enum */
    typeOut,       /* desired type of output, use nrrdTypeDefault for
                      "same as input" */
    renormalize,   /* when downsampling with a kernel with non-zero
                      integral, should we renormalize the weights to
                      match the kernel integral so as to remove
                      annoying ripple */
    roundlast,     /* when copying from the last intermediate
                      (floating point) result to the output nrrd,
                      for integer outputs, do we round to the nearest
                      integer first, before clamping and assigning.
                      Enabling this fixed the mystery of downsampling
                      large constant regions of 255 (uchar), and
                      ending up with 254
                      (renamed from "round" to avoid shadowing) */
    clamp,         /* when copying from the last intermediate
                      (floating point) result to the output nrrd,
                     should we clamp the values to the range of
                      values for the output type, a concern only for
                      integer outputs */
    defaultCenter, /* lacking known centering on input axis, what
                      centering to use when resampling */
    nonExistent;   /* from nrrdResampleNonExistent enum */
  double padValue; /* if padding, what value to pad with */
  /* ----------- input/internal ---------- */
  unsigned int dim,            /* dimension of nin (saved here to help
                                  manage state in NrrdResampleAxis[]) */
    passNum,                   /* number of passes needed */
    topRax, botRax,            /* fastest, slowest axes undergoing resampling */
    permute[NRRD_DIM_MAX + 1], /* how each pass permutes axes */
    passAxis[NRRD_DIM_MAX];    /* mapping from pass index to axis index */
  NrrdResampleAxis axis[NRRD_DIM_MAX + 1]; /* axis[j] stores information for input to
                                              pass which is resampling nin->axis[j];
                                              axis[NRRD_DIM_MAX] stores info about the
                                              final output of all passes */
  int *flag;                               /* flags for managing state */
  /* ----------- output ---------- */
  double time; /* time required for resampling */
} NrrdResampleContext;
/*
******** NrrdIter struct
**
** To hold values: either a single value, or a whole nrrd of values.
** Also, this facilitates iterating through those values
*/
typedef struct {
  const Nrrd *nrrd;             /* read-only nrrd to get values from */
  Nrrd *ownNrrd;                /* another nrrd to get values from, which we
                                   do "own", and do delete on nrrdIterNix */
  double val;                   /* single fixed value */
  size_t size;                  /* type size */
  char *data;                   /* where to get the next value */
  size_t left;                  /* number of values beyond what "data"
                                   currently points to */
  double (*load)(const void *); /* how to get a value out of "data" */
} NrrdIter;
/*
******** NrrdBoundarySpec
**
** In its present state, this is almost not worth having, but it nicely
** addresses the repeated annoyance of sometimes needing both a nrrdBoundary
** enum value and a pad value in a single place.  There may later be need for
** other kinds of parameterized boundary behaviors (such as padding with
** vector values, or some kind of parameterized high-order continuation)
*/
typedef struct {
  int boundary;    /* from nrrdBoundary enum */
  double padValue; /* padding value, if needed */
} NrrdBoundarySpec;
/* ---- END non-NrrdIO */
/******** defaults (nrrdDefault..) and state (nrrdState..) */
/* defaultsNrrd.c */
extern int nrrdDefaultWriteEncodingType;
extern int nrrdDefaultWriteBareText;
extern int nrrdDefaultWriteMoreThanFloatInText;
extern unsigned int nrrdDefaultWriteCharsPerLine;
extern unsigned int nrrdDefaultWriteValsPerLine;
/* ---- BEGIN non-NrrdIO */
extern int nrrdDefaultResampleBoundary;
extern int nrrdDefaultResampleType;
extern int nrrdDefaultResampleRenormalize;
extern int nrrdDefaultResampleRound;
extern int nrrdDefaultResampleClamp;
extern int nrrdDefaultResampleCheap;
extern double nrrdDefaultResamplePadValue;
extern int nrrdDefaultResampleNonExistent;
extern double nrrdDefaultKernelParm0;
/* ---- END non-NrrdIO */
extern int nrrdDefaultCenter;
extern double nrrdDefaultSpacing;
extern int nrrdStateVerboseIO;
extern int nrrdStateKeyValuePairsPropagate;
/* ---- BEGIN non-NrrdIO */
extern int nrrdStateBlind8BitRange;
extern int nrrdStateMeasureType;
extern int nrrdStateMeasureModeBins;
extern int nrrdStateMeasureHistoType;
extern int nrrdStateDisallowIntegerNonExist;
/* ---- END non-NrrdIO */
extern int nrrdStateAlwaysSetContent;
extern int nrrdStateDisableContent;
extern const char *nrrdStateUnknownContent;
extern int nrrdStateGrayscaleImage3D;
extern int nrrdStateKeyValueReturnInternalPointers;
extern int nrrdStateKindNoop;
/* ---- BEGIN non-NrrdIO */
extern const char *const nrrdEnvVarDefaultWriteEncodingType;
extern const char *const nrrdEnvVarDefaultWriteBareText;
extern const char *const nrrdEnvVarDefaultWriteBareTextOld;
extern const char *const nrrdEnvVarDefaultWriteMoreThanFloatInText;
extern const char *const nrrdEnvVarDefaultCenter;
extern const char *const nrrdEnvVarDefaultCenterOld;
extern const char *const nrrdEnvVarDefaultWriteCharsPerLine;
extern const char *const nrrdEnvVarDefaultWriteValsPerLine;
extern const char *const nrrdEnvVarDefaultKernelParm0;
extern const char *const nrrdEnvVarDefaultSpacing;
extern const char *const nrrdEnvVarStateKindNoop;
extern const char *const nrrdEnvVarStateVerboseIO;
extern const char *const nrrdEnvVarStateKeyValuePairsPropagate;
extern const char *const nrrdEnvVarStateBlind8BitRange;
extern const char *const nrrdEnvVarStateAlwaysSetContent;
extern const char *const nrrdEnvVarStateDisableContent;
extern const char *const nrrdEnvVarStateMeasureType;
extern const char *const nrrdEnvVarStateMeasureModeBins;
extern const char *const nrrdEnvVarStateMeasureHistoType;
extern const char *const nrrdEnvVarStateGrayscaleImage3D;
extern int nrrdGetenvBool(int *val, char **envStr, const char *envVar);
extern int nrrdGetenvEnum(int *val, char **envStr, const airEnum *enm,
                               const char *envVar);
extern int nrrdGetenvInt(int *val, char **envStr, const char *envVar);
extern int nrrdGetenvUInt(unsigned int *val, char **envStr, const char *envVar);
extern int nrrdGetenvDouble(double *val, char **envStr, const char *envVar);
extern int nrrdGetenvString(char **envStr, const char *envVar);
extern void nrrdDefaultGetenv(void);
extern void nrrdStateGetenv(void);
/* ---- END non-NrrdIO */
/******** all the airEnums used through-out nrrd */
/*
** the actual C enums are in nrrdEnums.h; experience has shown that it
** is not particularly useful to name those enums, since the shortest
** name is best used for the airEnums here
*/
/* enumsNrrd.c */
extern const airEnum *const nrrdFormatType;
extern const airEnum *const nrrdType;
extern const airEnum *const nrrdEncodingType;
extern const airEnum *const nrrdCenter;
extern const airEnum *const nrrdKind;
extern const airEnum *const nrrdField;
extern const airEnum *const nrrdSpace;
extern const airEnum *const nrrdSpacingStatus;
/* ---- BEGIN non-NrrdIO */
extern const airEnum *const nrrdFormatPNGsRGBIntent;
extern const airEnum *const nrrdOrientationHave;
extern const airEnum *const nrrdBoundary;
extern const airEnum *const nrrdMeasure;
extern const airEnum *const nrrdUnaryOp;
extern const airEnum *const nrrdBinaryOp;
extern const airEnum *const nrrdTernaryOp;
extern const airEnum *const nrrdFFTWPlanRigor;
extern const airEnum *const nrrdResampleNonExistent;
extern const airEnum *const nrrdMetaDataCanonicalVersion;
/* ---- END non-NrrdIO */
/******** arrays of things (poor-man's functions/predicates) */
/* arraysNrrd.c */
extern const char nrrdTypePrintfStr[NRRD_TYPE_MAX + 1][AIR_STRLEN_SMALL + 1];
extern const size_t nrrdTypeSize[NRRD_TYPE_MAX + 1];
extern const double nrrdTypeMin[NRRD_TYPE_MAX + 1];
extern const double nrrdTypeMax[NRRD_TYPE_MAX + 1];
extern const int nrrdTypeIsIntegral[NRRD_TYPE_MAX + 1];
extern const int nrrdTypeIsUnsigned[NRRD_TYPE_MAX + 1];
/******** pseudo-constructors, pseudo-destructors, and such */
/* methodsNrrd.c */
/* ---- BEGIN non-NrrdIO */
extern const int nrrdPresent;
extern NrrdBoundarySpec *nrrdBoundarySpecNew(void);
extern NrrdBoundarySpec *nrrdBoundarySpecNix(NrrdBoundarySpec *bspec);
extern NrrdBoundarySpec *nrrdBoundarySpecCopy(const NrrdBoundarySpec *bsp);
extern int nrrdBoundarySpecCheck(const NrrdBoundarySpec *bspec);
extern int nrrdBoundarySpecParse(NrrdBoundarySpec *bspec, const char *str);
extern int nrrdBoundarySpecSprint(char str[AIR_STRLEN_LARGE + 1],
                                       const NrrdBoundarySpec *bspec);
extern int nrrdBoundarySpecCompare(const NrrdBoundarySpec *bspecA,
                                        const NrrdBoundarySpec *bspecB,
                                        int *differ,
                                        char explain[AIR_STRLEN_LARGE + 1]);
/* ---- END non-NrrdIO */
extern NrrdIoState *nrrdIoStateNew(void);
extern void nrrdIoStateInit(NrrdIoState *nio);
extern NrrdIoState *nrrdIoStateNix(NrrdIoState *nio);
/* ---- BEGIN non-NrrdIO */
extern NrrdResampleInfo *nrrdResampleInfoNew(void);
extern NrrdResampleInfo *nrrdResampleInfoNix(NrrdResampleInfo *info);
extern NrrdKernelSpec *nrrdKernelSpecNew(void);
extern NrrdKernelSpec *nrrdKernelSpecCopy(const NrrdKernelSpec *ksp);
extern void nrrdKernelSpecSet(NrrdKernelSpec *ksp, const NrrdKernel *k,
                                   const double kparm[NRRD_KERNEL_PARMS_NUM]);
extern void nrrdKernelParmSet(const NrrdKernel **kP,
                                   double kparm[NRRD_KERNEL_PARMS_NUM],
                                   NrrdKernelSpec *ksp);
extern NrrdKernelSpec *nrrdKernelSpecNix(NrrdKernelSpec *ksp);
/* ---- END non-NrrdIO */
extern void nrrdInit(Nrrd *nrrd);
extern Nrrd *nrrdNew(void);
extern Nrrd *nrrdNix(Nrrd *nrrd);
extern Nrrd *nrrdEmpty(Nrrd *nrrd);
extern Nrrd *nrrdNuke(Nrrd *nrrd);
extern int nrrdWrap_nva(Nrrd *nrrd, void *data, int type, unsigned int dim,
                             const size_t *size);
extern int nrrdWrap_va(Nrrd *nrrd, void *data, int type, unsigned int dim,
                            ... /* size_t sx, sy, .., axis(dim-1) size */);
extern void nrrdBasicInfoInit(Nrrd *nrrd, int excludeBitflag);
extern int nrrdBasicInfoCopy(Nrrd *nout, const Nrrd *nin, int excludeBitflag);
extern int nrrdCopy(Nrrd *nout, const Nrrd *nin);
extern int nrrdAlloc_nva(Nrrd *nrrd, int type, unsigned int dim,
                              const size_t *size);
extern int nrrdAlloc_va(Nrrd *nrrd, int type, unsigned int dim,
                             ... /* size_t sx, sy, .., axis(dim-1) size */);
extern int nrrdMaybeAlloc_nva(Nrrd *nrrd, int type, unsigned int dim,
                                   const size_t *size);
extern int nrrdMaybeAlloc_va(Nrrd *nrrd, int type, unsigned int dim,
                                  ... /* size_t sx, sy, .., ax(dim-1) size */);
/* ---- BEGIN non-NrrdIO */
extern int nrrdCompare(const Nrrd *ninA, const Nrrd *ninB, int onlyData,
                            double epsilon, int *differ,
                            char explain[AIR_STRLEN_LARGE + 1]);
extern int nrrdPPM(Nrrd *, size_t sx, size_t sy);
extern int nrrdPGM(Nrrd *, size_t sx, size_t sy);
/* ---- END non-NrrdIO */
/******** axis info related */
/* axis.c */
extern int nrrdKindIsDomain(int kind);
extern unsigned int nrrdKindSize(int kind);
extern int nrrdAxisInfoCopy(Nrrd *nout, const Nrrd *nin, const int *axmap,
                                 int excludeBitflag);
extern void nrrdAxisInfoSet_nva(Nrrd *nin, int axInfo, const void *info);
extern void nrrdAxisInfoSet_va(Nrrd *nin, int axInfo, ... /* const void* */);
extern void nrrdAxisInfoGet_nva(const Nrrd *nrrd, int axInfo, void *info);
extern void nrrdAxisInfoGet_va(const Nrrd *nrrd, int axInfo, ... /* ??? */);
extern double nrrdAxisInfoPos(const Nrrd *nrrd, unsigned int ax, double idx);
extern double nrrdAxisInfoIdx(const Nrrd *nrrd, unsigned int ax, double pos);
extern void nrrdAxisInfoPosRange(double *loP, double *hiP, const Nrrd *nrrd,
                                      unsigned int ax, double loIdx, double hiIdx);
extern void nrrdAxisInfoIdxRange(double *loP, double *hiP, const Nrrd *nrrd,
                                      unsigned int ax, double loPos, double hiPos);
extern void nrrdAxisInfoSpacingSet(Nrrd *nrrd, unsigned int ax);
extern void nrrdAxisInfoMinMaxSet(Nrrd *nrrd, unsigned int ax, int defCenter);
/* ---- BEGIN non-NrrdIO */
extern int nrrdAxisInfoCompare(const NrrdAxisInfo *axisA,
                                    const NrrdAxisInfo *axisB,
                                    int *differ,
                                    char explain[AIR_STRLEN_LARGE + 1]);
/* ---- END non-NrrdIO */
extern unsigned int nrrdDomainAxesGet(const Nrrd *nrrd,
                                           unsigned int axisIdx[NRRD_DIM_MAX]);
extern unsigned int nrrdRangeAxesGet(const Nrrd *nrrd,
                                          unsigned int axisIdx[NRRD_DIM_MAX]);
extern unsigned int nrrdSpatialAxesGet(const Nrrd *nrrd,
                                            unsigned int axisIdx[NRRD_DIM_MAX]);
extern unsigned int nrrdNonSpatialAxesGet(const Nrrd *nrrd,
                                               unsigned int axisIdx[NRRD_DIM_MAX]);
extern int nrrdSpacingCalculate(const Nrrd *nrrd, unsigned int ax, double *spacing,
                                     double vector[NRRD_SPACE_DIM_MAX]);
extern int nrrdOrientationReduce(Nrrd *nout, const Nrrd *nin,
                                      int setMinsFromOrigin);
/* ---- BEGIN non-NrrdIO */
extern int nrrdMetaDataNormalize(Nrrd *nout, const Nrrd *nin, int version,
                                      int trivialOrient, int permuteComponentAxisFastest,
                                      int recenterGrid, double sampleSpacing,
                                      int *lostMeasurementFrame);
/* ---- END non-NrrdIO */
/******** simple things */
/* simple.c */
extern const char *const nrrdBiffKey;
extern unsigned int nrrdSpaceDimension(int space);
extern int nrrdSpaceSet(Nrrd *nrrd, int space);
extern int nrrdSpaceDimensionSet(Nrrd *nrrd, unsigned int spaceDim);
extern unsigned int nrrdSpaceOriginGet(const Nrrd *nrrd,
                                            double vector[NRRD_SPACE_DIM_MAX]);
extern int nrrdSpaceOriginSet(Nrrd *nrrd, const double *vector);
extern int nrrdOriginCalculate(const Nrrd *nrrd, unsigned int *axisIdx,
                                    unsigned int axisIdxNum, int defaultCenter,
                                    double *origin);
extern int nrrdContentSet_va(Nrrd *nout, const char *func, const Nrrd *nin,
                                  const char *format, ... /* printf-style arg list */);
extern void nrrdDescribe(FILE *file, const Nrrd *nrrd);
extern int nrrdCheck(const Nrrd *nrrd);
extern int _nrrdCheck(const Nrrd *nrrd, int checkData, int useBiff);
extern size_t nrrdElementSize(const Nrrd *nrrd);
extern size_t nrrdElementNumber(const Nrrd *nrrd);
extern int nrrdSanity(void);
extern int nrrdSameSize(const Nrrd *n1, const Nrrd *n2, int useBiff);
extern void nrrdSpaceVecCopy(double dst[NRRD_SPACE_DIM_MAX],
                                  const double src[NRRD_SPACE_DIM_MAX]);
extern void nrrdSpaceVecScaleAdd2(double sum[NRRD_SPACE_DIM_MAX],
                                       double sclA,
                                       const double vecA[NRRD_SPACE_DIM_MAX],
                                       double sclB,
                                       const double vecB[NRRD_SPACE_DIM_MAX]);
extern void nrrdSpaceVecScale(double out[NRRD_SPACE_DIM_MAX],
                                   double scl,
                                   const double vec[NRRD_SPACE_DIM_MAX]);
extern double nrrdSpaceVecNorm(unsigned int sdim,
                                    const double vec[NRRD_SPACE_DIM_MAX]);
extern int nrrdSpaceVecExists(unsigned int sdim,
                                   const double vec[NRRD_SPACE_DIM_MAX]);
extern void nrrdSpaceVecSetNaN(double vec[NRRD_SPACE_DIM_MAX]);
/* ---- BEGIN non-NrrdIO */
extern void nrrdSanityOrDie(const char *me);
extern void nrrdSpaceVecSetZero(double vec[NRRD_SPACE_DIM_MAX]);
extern void nrrdZeroSet(Nrrd *nout);
extern void nrrdNaNSet(Nrrd *nout);
/* ---- END non-NrrdIO */
/******** comments related */
/* comment.c */
extern int nrrdCommentAdd(Nrrd *nrrd, const char *str);
extern void nrrdCommentClear(Nrrd *nrrd);
extern int nrrdCommentCopy(Nrrd *nout, const Nrrd *nin);
/******** key/value pairs */
/* keyvalue.c */
extern unsigned int nrrdKeyValueSize(const Nrrd *nrrd);
extern int nrrdKeyValueAdd(Nrrd *nrrd, const char *key, const char *value);
extern char *nrrdKeyValueGet(const Nrrd *nrrd, const char *key);
extern void nrrdKeyValueIndex(const Nrrd *nrrd, char **keyP, char **valueP,
                                   unsigned int ki);
extern int nrrdKeyValueErase(Nrrd *nrrd, const char *key);
extern void nrrdKeyValueClear(Nrrd *nrrd);
extern int nrrdKeyValueCopy(Nrrd *nout, const Nrrd *nin);
/******** endian related */
/* endianNrrd.c */
extern void nrrdSwapEndian(Nrrd *nrrd);
/******** getting information to and from files */
/* formatXXX.c */
extern const NrrdFormat *const nrrdFormatNRRD;
extern const NrrdFormat *const nrrdFormatPNM;
extern const NrrdFormat *const nrrdFormatPNG;
extern const NrrdFormat *const nrrdFormatVTK;
extern const NrrdFormat *const nrrdFormatText;
extern const NrrdFormat *const nrrdFormatEPS;
/* format.c */
extern const NrrdFormat *const nrrdFormatUnknown;
extern const NrrdFormat *const nrrdFormatArray[NRRD_FORMAT_TYPE_MAX + 1];
/* encodingXXX.c */
extern const NrrdEncoding *const nrrdEncodingRaw;
extern const NrrdEncoding *const nrrdEncodingAscii;
extern const NrrdEncoding *const nrrdEncodingHex;
extern const NrrdEncoding *const nrrdEncodingGzip;
extern const NrrdEncoding *const nrrdEncodingBzip2;
extern const NrrdEncoding *const nrrdEncodingZRL;
/* encoding.c */
extern const NrrdEncoding *const nrrdEncodingUnknown;
extern const NrrdEncoding *const nrrdEncodingArray[NRRD_ENCODING_TYPE_MAX + 1];
/* parseNrrd.c */
/* this needs the "FILE *file" first arg for the sole reason that
   parsing a "data file: " field which identifies a LIST must then
   read in all the data filenames from the same file */
extern int (*const nrrdFieldInfoParse[NRRD_FIELD_MAX + 1])(FILE *file, Nrrd *nrrd,
                                                                NrrdIoState *nio,
                                                                int useBiff);
extern unsigned int _nrrdDataFNNumber(NrrdIoState *nio);
extern int nrrdContainsPercentThisAndMore(const char *str, char thss);
extern int _nrrdDataFNCheck(NrrdIoState *nio, Nrrd *nrrd, int useBiff);
/* ---- BEGIN non-NrrdIO */
extern int nrrdSpaceVectorParse(double dir[NRRD_SPACE_DIM_MAX], const char *str,
                                     unsigned int spaceDim, int useBiff);
/* ---- END non-NrrdIO */
extern size_t (*const nrrdStringValsParse[NRRD_TYPE_MAX + 1])(void *out,
                                                                   const char *s,
                                                                   const char *sep,
                                                                   size_t n);
/* read.c */
extern int nrrdOneLine(unsigned int *lenP, NrrdIoState *nio, FILE *file);
extern int nrrdLineSkip(FILE *dataFile, NrrdIoState *nio);
extern int nrrdByteSkip(FILE *dataFile, Nrrd *nrrd, NrrdIoState *nio);
extern int nrrdLoad(Nrrd *nrrd, const char *filename, NrrdIoState *nio);
extern int nrrdLoadMulti(Nrrd *const *nin, unsigned int ninLen,
                              const char *fnameFormat, unsigned int numStart,
                              NrrdIoState *nio);
extern int nrrdRead(Nrrd *nrrd, FILE *file, NrrdIoState *nio);
extern int nrrdStringRead(Nrrd *nrrd, const char *string, NrrdIoState *nio);
/* write.c */
extern int nrrdIoStateSet(NrrdIoState *nio, int parm, int value);
extern int nrrdIoStateEncodingSet(NrrdIoState *nio, const NrrdEncoding *encoding);
extern int nrrdIoStateFormatSet(NrrdIoState *nio, const NrrdFormat *format);
extern int nrrdIoStateGet(NrrdIoState *nio, int parm);
extern const NrrdEncoding *nrrdIoStateEncodingGet(NrrdIoState *nio);
extern const NrrdFormat *nrrdIoStateFormatGet(NrrdIoState *nio);
extern int nrrdSave(const char *filename, const Nrrd *nrrd, NrrdIoState *nio);
extern int nrrdSaveMulti(const char *fnameFormat, const Nrrd *const *nin,
                              unsigned int ninLen, unsigned int numStart,
                              NrrdIoState *nio);
extern int nrrdWrite(FILE *file, const Nrrd *nrrd, NrrdIoState *nio);
extern int nrrdStringWrite(char **stringP, const Nrrd *nrrd, NrrdIoState *nio);
/******** getting value into and out of an array of general type, and
   all other simplistic functionality pseudo-parameterized by type */
/* accessors.c */
extern double (*const nrrdDLoad[NRRD_TYPE_MAX + 1])(const void *v);
extern float (*const nrrdFLoad[NRRD_TYPE_MAX + 1])(const void *v);
extern int (*const nrrdILoad[NRRD_TYPE_MAX + 1])(const void *v);
extern unsigned int (*const nrrdUILoad[NRRD_TYPE_MAX + 1])(const void *v);
extern double (*const nrrdDStore[NRRD_TYPE_MAX + 1])(void *v, double d);
extern float (*const nrrdFStore[NRRD_TYPE_MAX + 1])(void *v, float f);
extern int (*const nrrdIStore[NRRD_TYPE_MAX + 1])(void *v, int j);
extern unsigned int (*const nrrdUIStore[NRRD_TYPE_MAX + 1])(void *v,
                                                                 unsigned int j);
extern double (*const nrrdDLookup[NRRD_TYPE_MAX + 1])(const void *v, size_t I);
extern float (*const nrrdFLookup[NRRD_TYPE_MAX + 1])(const void *v, size_t I);
extern int (*const nrrdILookup[NRRD_TYPE_MAX + 1])(const void *v, size_t I);
extern unsigned int (*const nrrdUILookup[NRRD_TYPE_MAX + 1])(const void *v,
                                                                  size_t I);
extern double (*const nrrdDInsert[NRRD_TYPE_MAX + 1])(void *v, size_t I, double d);
extern float (*const nrrdFInsert[NRRD_TYPE_MAX + 1])(void *v, size_t I, float f);
extern int (*const nrrdIInsert[NRRD_TYPE_MAX + 1])(void *v, size_t I, int j);
extern unsigned int (*const nrrdUIInsert[NRRD_TYPE_MAX + 1])(void *v, size_t I,
                                                                  unsigned int j);
extern int (*const nrrdSprint[NRRD_TYPE_MAX + 1])(char *, const void *);
/* ---- BEGIN non-NrrdIO */
extern int (*const nrrdFprint[NRRD_TYPE_MAX + 1])(FILE *, const void *);
extern void (*const nrrdMinMaxExactFind[NRRD_TYPE_MAX + 1])(void *minP,
                                                                 void *maxP,
                                                                 int *hasNonExistP,
                                                                 const Nrrd *nrrd);
extern int (*const nrrdValCompare[NRRD_TYPE_MAX + 1])(const void *, const void *);
extern int (*const nrrdValCompareInv[NRRD_TYPE_MAX + 1])(const void *,
                                                              const void *);
extern int nrrdArrayCompare(int type, const void *valA, const void *valB,
                                 size_t valNum, double epsilon, int *differ,
                                 char explain[AIR_STRLEN_LARGE + 1]);
/* ---- END non-NrrdIO */
/******** permuting, shuffling, and all flavors of reshaping */
/* reorder.c */
extern int nrrdAxesInsert(Nrrd *nout, const Nrrd *nin, unsigned int ax);
extern int nrrdInvertPerm(unsigned int *invp, const unsigned int *perm,
                               unsigned int n);
extern int nrrdAxesPermute(Nrrd *nout, const Nrrd *nin, const unsigned int *axes);
extern int nrrdShuffle(Nrrd *nout, const Nrrd *nin, unsigned int axis,
                            const size_t *perm);
/* ---- BEGIN non-NrrdIO */
extern int nrrdAxesSwap(Nrrd *nout, const Nrrd *nin, unsigned int ax1,
                             unsigned int ax2);
extern int nrrdFlip(Nrrd *nout, const Nrrd *nin, unsigned int axis);
extern int nrrdJoin(Nrrd *nout, const Nrrd *const *nin, unsigned int numNin,
                         unsigned int axis, int incrDim);
extern int nrrdReshape_va(Nrrd *nout, const Nrrd *nin, unsigned int dim,
                               ... /* sx, sy, .., axis(dim-1) size */);
extern int nrrdReshape_nva(Nrrd *nout, const Nrrd *nin, unsigned int dim,
                                const size_t *size);
extern int nrrdAxesSplit(Nrrd *nout, const Nrrd *nin, unsigned int ax,
                              size_t sizeFast, size_t sizeSlow);
extern int nrrdAxesDelete(Nrrd *nout, const Nrrd *nin, unsigned int ax);
extern int nrrdAxesMerge(Nrrd *nout, const Nrrd *nin, unsigned int ax);
extern int nrrdBlock(Nrrd *nout, const Nrrd *nin);
extern int nrrdUnblock(Nrrd *nout, const Nrrd *nin, int type);
extern int nrrdTile2D(Nrrd *nout, const Nrrd *nin, unsigned int ax0,
                           unsigned int ax1, unsigned int axSplit, size_t sizeFast,
                           size_t sizeSlow);
extern int nrrdUntile2D(Nrrd *nout, const Nrrd *nin, unsigned int ax0,
                             unsigned int ax1, unsigned int axMerge, size_t sizeFast,
                             size_t sizeSlow);
/******** things useful with hest */
/* hestNrrd.c */
extern const hestCB *const nrrdHestNrrd;
extern const hestCB *const nrrdHestNrrdNoTTY;
extern const hestCB *const nrrdHestKernelSpec;
extern const hestCB *const nrrdHestBoundarySpec;
extern const hestCB *const nrrdHestIter;
/******** nrrd value iterator gadget */
/* iter.c */
extern NrrdIter *nrrdIterNew(void);
extern void nrrdIterSetValue(NrrdIter *iter, double val);
extern void nrrdIterSetNrrd(NrrdIter *iter, const Nrrd *nrrd);
extern void nrrdIterSetOwnNrrd(NrrdIter *iter, Nrrd *nrrd);
extern double nrrdIterValue(NrrdIter *iter);
extern char *nrrdIterContent(NrrdIter *iter);
extern NrrdIter *nrrdIterNix(NrrdIter *iter);
/******** expressing the range of values in a nrrd */
/* range.c */
extern NrrdRange *nrrdRangeNew(double min, double max);
extern NrrdRange *nrrdRangeCopy(const NrrdRange *range);
extern NrrdRange *nrrdRangeNix(NrrdRange *range);
extern void nrrdRangeReset(NrrdRange *range);
extern void nrrdRangeSet(NrrdRange *range, const Nrrd *nrrd, int blind8BitRange);
extern int nrrdRangePercentileSet(NrrdRange *range, const Nrrd *nrrd,
                                       double minPerc, double maxPerc,
                                       unsigned int hbins, int blind8BitRange);
extern int nrrdRangePercentileFromStringSet(NrrdRange *range,
                                                 const Nrrd *nrrd,
                                                 const char *minStr,
                                                 const char *maxStr,
                                                 int zeroCenter,
                                                 unsigned int hbins,
                                                 int blind8BitRange);
extern void nrrdRangeSafeSet(NrrdRange *range, const Nrrd *nrrd,
                                  int blind8BitRange);
extern NrrdRange *nrrdRangeNewSet(const Nrrd *nrrd, int blind8BitRange);
extern int nrrdHasNonExist(const Nrrd *nrrd);
/******** some of the point-wise value remapping, conversion, and such */
/* convertNrrd.c */
extern float (*const nrrdFClamp[NRRD_TYPE_MAX + 1])(float);
extern double (*const nrrdDClamp[NRRD_TYPE_MAX + 1])(double);
/* map.c */
extern int nrrdConvert(Nrrd *nout, const Nrrd *nin, int type);
extern int nrrdClampConvert(Nrrd *nout, const Nrrd *nin, int type);
extern int nrrdCastClampRound(Nrrd *nout, const Nrrd *nin, int type, int doClamp,
                                   int roundDir);
extern int nrrdQuantize(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                             unsigned int bits);
extern int nrrdUnquantize(Nrrd *nout, const Nrrd *nin, int type);
extern int nrrdHistoEq(Nrrd *nout, const Nrrd *nin, Nrrd **nhistP,
                            unsigned int bins, unsigned int smart, float amount);
/******** rest of point-wise value remapping, and "color"mapping */
/* apply1D.c */
extern int nrrdApply1DLut(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                               const Nrrd *nlut, int typeOut, int rescale);
extern int nrrdApplyMulti1DLut(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                                    const Nrrd *nmlut, int typeOut, int rescale);
extern int nrrdApply1DRegMap(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                                  const Nrrd *nmap, int typeOut, int rescale);
extern int nrrdApplyMulti1DRegMap(Nrrd *nout, const Nrrd *nin,
                                       const NrrdRange *range, const Nrrd *nmmap,
                                       int typeOut, int rescale);
extern int nrrd1DIrregMapCheck(const Nrrd *nmap);
extern int nrrd1DIrregAclGenerate(Nrrd *nacl, const Nrrd *nmap, size_t aclLen);
extern int nrrd1DIrregAclCheck(const Nrrd *nacl);
extern int nrrdApply1DIrregMap(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                                    const Nrrd *nmap, const Nrrd *nacl, int typeOut,
                                    int rescale);
extern int nrrdApply1DSubstitution(Nrrd *nout, const Nrrd *nin, const Nrrd *nsubst);
/* apply2D.c */
extern int nrrdApply2DLut(Nrrd *nout, const Nrrd *nin, unsigned int domainAxis,
                               const NrrdRange *range0, const NrrdRange *range1,
                               const Nrrd *nlut, int typeOut, int rescale0,
                               int rescale1);
/* ---- END non-NrrdIO */
/******** sampling, slicing, cropping */
/* subset.c */
extern int nrrdSlice(Nrrd *nout, const Nrrd *nin, unsigned int axis, size_t pos);
extern int nrrdCrop(Nrrd *nout, const Nrrd *nin, size_t *min, size_t *max);
/* ---- BEGIN non-NrrdIO */
extern int nrrdSliceSelect(Nrrd *noutAbove, Nrrd *noutBelow, const Nrrd *nin,
                                unsigned int axi, Nrrd *nline, double thresh);
extern int nrrdSample_nva(void *val, const Nrrd *nin, const size_t *coord);
extern int nrrdSample_va(void *val, const Nrrd *nin,
                              ... /* size_t idx0, idx1, .., idx(dim-1) */);
extern int nrrdSimpleCrop(Nrrd *nout, const Nrrd *nin, unsigned int crop);
extern int nrrdCropAuto(Nrrd *nout, const Nrrd *nin, size_t _min[NRRD_DIM_MAX],
                             size_t _max[NRRD_DIM_MAX], const unsigned int *keep,
                             unsigned int keepNum, int measr, double frac, int offset);
/******** padding */
/* superset.c */
extern int nrrdSplice(Nrrd *nout, const Nrrd *nin, const Nrrd *nslice,
                           unsigned int axis, size_t pos);
extern int nrrdPad_nva(Nrrd *nout, const Nrrd *nin, const ptrdiff_t *min,
                            const ptrdiff_t *max, int boundary, double padValue);
extern int nrrdPad_va(Nrrd *nout, const Nrrd *nin, const ptrdiff_t *min,
                           const ptrdiff_t *max, int boundary,
                           ... /* double value (if nrrdBoundaryPad) */);
extern int nrrdSimplePad_nva(Nrrd *nout, const Nrrd *nin, unsigned int pad,
                                  int boundary, double padValue);
extern int nrrdSimplePad_va(Nrrd *nout, const Nrrd *nin, unsigned int pad,
                                 int boundary,
                                 ... /* double value (if nrrdBoundaryPad) */);
extern int nrrdInset(Nrrd *nout, const Nrrd *nin, const Nrrd *nsub,
                          const size_t *min);
/******** measuring and projecting */
/* measure.c */
extern void (*const nrrdMeasureLine[NRRD_MEASURE_MAX + 1])(void *ans, int ansType,
                                                                const void *line,
                                                                int lineType,
                                                                size_t lineLen,
                                                                double axMin,
                                                                double axMax);
extern int nrrdProject(Nrrd *nout, const Nrrd *nin, unsigned int axis, int measr,
                            int type);
/********* various kinds of histograms and their analysis */
/* histogram.c */
extern int nrrdHisto(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                          const Nrrd *nwght, size_t bins, int type);
extern int nrrdHistoCheck(const Nrrd *nhist);
extern int nrrdHistoDraw(Nrrd *nout, const Nrrd *nin, size_t sy, int showLog,
                              double max);
extern int nrrdHistoAxis(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                              unsigned int axis, size_t bins, int type);
extern int nrrdHistoJoint(Nrrd *nout, const Nrrd *const *nin,
                               const NrrdRange *const *range, unsigned int ninNum,
                               const Nrrd *nwght, const size_t *bins, int type,
                               const int *clamp);
extern int nrrdHistoThresholdOtsu(double *threshP, const Nrrd *nhist, double expo);
/******** arithmetic and math on nrrds */
/* arith.c */
extern double nrrdSRGBGamma(double val);
extern double nrrdSRGBGammaInverse(double val);
extern int nrrdArithGamma(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                               double gamma);
extern int nrrdArithSRGBGamma(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                                   int forward);
extern int nrrdArithUnaryOp(Nrrd *nout, int op, const Nrrd *nin);
extern int nrrdArithBinaryOp(Nrrd *nout, int op, const Nrrd *ninA,
                                  const Nrrd *ninB);
extern int nrrdArithTernaryOp(Nrrd *nout, int op, const Nrrd *ninA,
                                   const Nrrd *ninB, const Nrrd *ninC);
extern int nrrdArithAffine(Nrrd *nout, double minIn, const Nrrd *nin, double maxIn,
                                double minOut, double maxOut, int clamp);
extern int nrrdArithIterBinaryOp(Nrrd *nout, int op, NrrdIter *inA, NrrdIter *inB);
extern int nrrdArithIterBinaryOpSelect(Nrrd *nout, int op, NrrdIter *inA,
                                            NrrdIter *inB, unsigned int which);
extern int nrrdArithIterTernaryOp(Nrrd *nout, int op, NrrdIter *inA, NrrdIter *inB,
                                       NrrdIter *inC);
extern int nrrdArithIterTernaryOpSelect(Nrrd *nout, int op, NrrdIter *inA,
                                             NrrdIter *inB, NrrdIter *inC,
                                             unsigned int which);
extern int nrrdArithIterAffine(Nrrd *nout, NrrdIter *minIn, NrrdIter *in,
                                    NrrdIter *maxIn, NrrdIter *minOut, NrrdIter *maxOut,
                                    int clamp);
extern unsigned int nrrdCRC32(const Nrrd *nin, int endian);
/******** filtering and re-sampling */
/* filt.c */
extern int nrrdCheapMedian(Nrrd *nout, const Nrrd *nin, int pad, int mode,
                                unsigned int radius, float wght, unsigned int bins);
extern int nrrdDistanceL2(Nrrd *nout, const Nrrd *nin, int typeOut,
                               const int *axisDo, double thresh, int insideHigher);
extern int nrrdDistanceL2Biased(Nrrd *nout, const Nrrd *nin, int typeOut,
                                     const int *axisDo, double thresh, double bias,
                                     int insideHigher);
extern int nrrdDistanceL2Signed(Nrrd *nout, const Nrrd *nin, int typeOut,
                                     const int *axisDo, double thresh, int insideHigher);
/******** deringNrrd.c: deringing CT */
typedef struct {
  /* -------- INPUT */
  int verbose,               /* blah blah blah */
    linearInterp,            /* instead of nearest neighbor in polar txf */
    verticalSeam;            /* dering left and right sides of image
                                separately, asserting that there are no
                                rings along vertical line through center */
  const Nrrd *nin;           /* array to dering */
  double center[2],          /* location of recon center in index space
                                of fastest two axes */
    clampPerc[2],            /* percentiles above 0.0 and below 1.0 at which
                                to clamp values (for ring estimation) from
                                below and above, respectively. Setting both
                                to zero means no such clamping */
    radiusScale;             /* radius scaling to polar txf */
  unsigned int thetaNum,     /* number of samples in theta in polar txf */
    clampHistoBins;          /* number of bins in histogram for computing
                                clamping in terms of percentiles */
  const NrrdKernel *rkernel; /* kernel for radial high-pass filtering */
  double rkparm[NRRD_KERNEL_PARMS_NUM];
  const NrrdKernel *tkernel; /* kernel for blurring along theta */
  double tkparm[NRRD_KERNEL_PARMS_NUM];
  /* -------- INTERNAL */
  const char *cdataIn; /* nin->data as char* */
  char *cdataOut;      /* nout->data as char* */
  size_t sliceSize;    /* sizeof slice */
  int clampDo;         /* is there really is clamping to be done */
  double clamp[2];     /* clamping values implied by clampPerc */
  /* -------- OUTPUT */
  double ringMagnitude; /* L2 norm of ring map; may be useful for
                           optimizing an (unknown) center location */
} NrrdDeringContext;
extern NrrdDeringContext *nrrdDeringContextNew(void);
extern NrrdDeringContext *nrrdDeringContextNix(NrrdDeringContext *drc);
extern int nrrdDeringVerboseSet(NrrdDeringContext *drc, int verbose);
extern int nrrdDeringLinearInterpSet(NrrdDeringContext *drc, int linterp);
extern int nrrdDeringVerticalSeamSet(NrrdDeringContext *drc, int vertSeam);
extern int nrrdDeringInputSet(NrrdDeringContext *drc, const Nrrd *nin);
extern int nrrdDeringCenterSet(NrrdDeringContext *drc, double cx, double cy);
extern int nrrdDeringClampPercSet(NrrdDeringContext *drc, double lo, double hi);
extern int nrrdDeringClampHistoBinsSet(NrrdDeringContext *drc, unsigned int bins);
extern int nrrdDeringRadiusScaleSet(NrrdDeringContext *drc, double rsc);
extern int nrrdDeringThetaNumSet(NrrdDeringContext *drc, unsigned int thetaNum);
extern int nrrdDeringRadialKernelSet(NrrdDeringContext *drc,
                                          const NrrdKernel *rkernel,
                                          const double rkparm[NRRD_KERNEL_PARMS_NUM]);
extern int nrrdDeringThetaKernelSet(NrrdDeringContext *drc,
                                         const NrrdKernel *tkernel,
                                         const double tkparm[NRRD_KERNEL_PARMS_NUM]);
extern int nrrdDeringExecute(NrrdDeringContext *drc, Nrrd *nout);
/*
******** nrrdResample_t typedef
**
** type used to hold filter sample locations and weights in
** nrrdSpatialResample(), and to hold the intermediate sampling
** results.  Not as good as templating, but better than hard-coding
** float versus double.  Actually, the difference between float and
** double is not exposed in any functions or objects declared in this
** header; it is entirely internal to the operation of
** nrrdSpatialResample() and nrrdResampleExecute() and things
** based on those.
**
** Choose by setting "#if" arg to 1 (for float) or 0 (for double)
*/
/* resampleContext.c */
extern NrrdResampleContext *nrrdResampleContextNew(void);
extern NrrdResampleContext *nrrdResampleContextNix(NrrdResampleContext *);
extern int nrrdResampleDefaultCenterSet(NrrdResampleContext *rsmc, int center);
extern int nrrdResampleNonExistentSet(NrrdResampleContext *rsmc, int nonExistent);
extern int nrrdResampleNrrdSet(NrrdResampleContext *rsmc, const Nrrd *nin);
extern int nrrdResampleInputSet(NrrdResampleContext *rsmc, const Nrrd *nin);
extern int nrrdResampleKernelSet(NrrdResampleContext *rsmc,
                                      unsigned int axIdx,
                                      const NrrdKernel *kernel,
                                      double kparm[NRRD_KERNEL_PARMS_NUM]);
extern int nrrdResampleSamplesSet(NrrdResampleContext *rsmc,
                                       unsigned int axIdx,
                                       size_t samples);
extern int nrrdResampleRangeSet(NrrdResampleContext *rsmc, unsigned int axIdx,
                                     double min, double max);
extern int nrrdResampleOverrideCenterSet(NrrdResampleContext *rsmc,
                                              unsigned int axIdx,
                                              int center);
extern int nrrdResampleRangeFullSet(NrrdResampleContext *rsmc, unsigned int axIdx);
extern int nrrdResampleBoundarySet(NrrdResampleContext *rsmc, int boundary);
extern int nrrdResamplePadValueSet(NrrdResampleContext *rsmc, double padValue);
extern int nrrdResampleBoundarySpecSet(NrrdResampleContext *rsmc,
                                            const NrrdBoundarySpec *bspec);
extern int nrrdResampleTypeOutSet(NrrdResampleContext *rsmc, int typeOut);
extern int nrrdResampleRenormalizeSet(NrrdResampleContext *rsmc, int renormalize);
extern int nrrdResampleRoundSet(NrrdResampleContext *rsmc, int round);
extern int nrrdResampleClampSet(NrrdResampleContext *rsmc, int clamp);
extern int nrrdResampleExecute(NrrdResampleContext *rsmc, Nrrd *nout);
/* resampleNrrd.c */
extern int nrrdSpatialResample(Nrrd *nout, const Nrrd *nin,
                                    const NrrdResampleInfo *info);
extern int nrrdSimpleResample(Nrrd *nout, const Nrrd *nin, const NrrdKernel *kernel,
                                   const double *parm, const size_t *samples,
                                   const double *scalings);
/******** connected component extraction and manipulation */
/* ccmethods.c */
extern int nrrdCCValid(const Nrrd *nin);
extern unsigned int nrrdCCSize(Nrrd *nout, const Nrrd *nin);
extern unsigned int nrrdCCMax(const Nrrd *nin);
extern unsigned int nrrdCCNum(const Nrrd *nin);
/* cc.c */
extern int nrrdCCFind(Nrrd *nout, Nrrd **nvalP, const Nrrd *nin, int type,
                           unsigned int conny);
extern int nrrdCCAdjacency(Nrrd *nout, const Nrrd *nin, unsigned int conny);
extern int nrrdCCMerge(Nrrd *nout, const Nrrd *nin, Nrrd *nval, int dir,
                            unsigned int maxSize, unsigned int maxNeighbor,
                            unsigned int conny);
extern int nrrdCCRevalue(Nrrd *nout, const Nrrd *nin, const Nrrd *nval);
extern int nrrdCCSettle(Nrrd *nout, Nrrd **nvalP, const Nrrd *nin);
/******** FFT */
/* fftNrrd.c */
extern const int nrrdFFTWEnabled;
extern int nrrdFFTWWisdomRead(FILE *file);
extern int nrrdFFT(Nrrd *nout, const Nrrd *nin, unsigned int *axes,
                        unsigned int axesLen, int sign, int rescale, int preCompLevel);
extern int nrrdFFTWWisdomWrite(FILE *file);
/******** kernels (interpolation, 1st and 2nd derivatives) */
/* new kernels should also be registered with
   meet/meetNrrd.c/meetNrrdKernelAll() */
/* tmfKernel.c
   nrrdKernelTMF[D+1][C+1][A] is d<D>_c<C>_<A>ef:
   Dth-derivative, C-order continuous ("smooth"), A-order accurate
   (for D and C, index 0 accesses the function for -1) */
extern const NrrdKernel *const nrrdKernelTMF[4][5][5];
extern const unsigned int nrrdKernelTMF_maxD;
extern const unsigned int nrrdKernelTMF_maxC;
extern const unsigned int nrrdKernelTMF_maxA;
/* clang-format off */
/* winKernel.c : various kinds of windowed sincs */
extern const NrrdKernel
  *const nrrdKernelHann,         /* Hann (cosine-bell) windowed sinc */
  *const nrrdKernelHannD,        /* 1st derivative of Hann windowed since */
  *const nrrdKernelHannDD,       /* 2nd derivative */
  *const nrrdKernelBlackman,     /* Blackman windowed sinc */
  *const nrrdKernelBlackmanD,    /* 1st derivative of Blackman windowed sinc */
  *const nrrdKernelBlackmanDD;   /* 2nd derivative */
/* bsplKernel.c: b-splines of various orders; these do not interpolate,
   but the ApproxInverse kernels are ok for pre-filtering so that they do */
extern const NrrdKernel
  *const nrrdKernelBSpline1,     /* 1st order B-spline */
  *const nrrdKernelBSpline1D,
  *const nrrdKernelBSpline2,     /* 2nd order (quadratic) B-spline */
  *const nrrdKernelBSpline2D,
  *const nrrdKernelBSpline2DD,
  *const nrrdKernelBSpline3,     /* 3rd order (cubic) B-spline */
  *const nrrdKernelBSpline3D,
  *const nrrdKernelBSpline3DD,
  *const nrrdKernelBSpline3DDD,
  *const nrrdKernelBSpline3ApproxInverse,
  *const nrrdKernelBSpline4,     /* 4rd order B-spline */
  *const nrrdKernelBSpline4D,
  *const nrrdKernelBSpline4DD,
  *const nrrdKernelBSpline4DDD,
  *const nrrdKernelBSpline5,     /* 5th order B-spline */
  *const nrrdKernelBSpline5D,
  *const nrrdKernelBSpline5DD,
  *const nrrdKernelBSpline5DDD,
  *const nrrdKernelBSpline5ApproxInverse,
  *const nrrdKernelBSpline6,     /* 6th order B-spline */
  *const nrrdKernelBSpline6D,
  *const nrrdKernelBSpline6DD,
  *const nrrdKernelBSpline6DDD,
  *const nrrdKernelBSpline7,     /* 7th order B-spline */
  *const nrrdKernelBSpline7D,
  *const nrrdKernelBSpline7DD,
  *const nrrdKernelBSpline7DDD,
  *const nrrdKernelBSpline7ApproxInverse;
/* kernel.c: the rest of the kernels and kernel utility functions */
extern const NrrdKernel
  *const nrrdKernelZero,         /* zero everywhere (though still takes
                                    a single "support" parm[0]) */
  *const nrrdKernelFlag,         /* behaves like nrrdKernelZero, but serves
                                    as a flag that some kernel-related logic
                                    has gone south */
  *const nrrdKernelBox,          /* box filter (nearest neighbor) */
  *const nrrdKernelBoxSupportDebug, /* box kernel but with an adjustable
                                       support, not for changing the shape of
                                       the kernel (as with nrrdKernelBox), but
                                       for exercising functions (like nrrd's
                                       resampling or gage's probing) that
                                       depend on kernel support */
  *const nrrdKernelCos4SupportDebug, /* like BoxSupportDebug but instead of
                                        box function, using cos(pi*x)^4
                                        within [-0.5,0.5] and 0.0 outside */
  *const nrrdKernelCos4SupportDebugD,
  *const nrrdKernelCos4SupportDebugDD,
  *const nrrdKernelCos4SupportDebugDDD,
  *const nrrdKernelCatmullRomSupportDebug,
  *const nrrdKernelCatmullRomSupportDebugD,
  *const nrrdKernelCatmullRomSupportDebugDD,
  *const nrrdKernelCheap,        /* an unusual and specially-handled kernel
                                    that evaluates to abs(x), for the
                                    singular purpose of enabling nearest
                                    neighbor downsampling */
  *const nrrdKernelHermiteScaleSpaceFlag,  /* a kernel that looks like tent,
                                              but which exists as a flag for
                                              particular gage behavior in the
                                              context of doing interpolation
                                              along scale in scale-space */
  *const nrrdKernelTent,         /* tent filter (linear interpolation) */
  *const nrrdKernelForwDiff,     /* forward-difference-ish 1st deriv. */
  *const nrrdKernelCentDiff,     /* central-difference-ish 1st deriv. */
  *const nrrdKernelBCCubic,      /* BC family of cubic polynomial splines */
  *const nrrdKernelBCCubicD,     /* 1st deriv. of BC cubic family */
  *const nrrdKernelBCCubicDD,    /* 2nd deriv. of BC cubic family */
  *const nrrdKernelCatmullRom,   /* aka cubic:0,0.5 */
  *const nrrdKernelCatmullRomD,  /* aka cubicd:0,0.5 */
  *const nrrdKernelCatmullRomDD, /* aka cubicdd:0,0.5 */
  *const nrrdKernelAQuartic,     /* A family of quartic C2 interp. splines */
  *const nrrdKernelAQuarticD,    /* 1st deriv. of A quartic family */
  *const nrrdKernelAQuarticDD,   /* 2nd deriv. of A quartic family */
  *const nrrdKernelC3Quintic,    /* 0-parm C3 quintic, support [-2,2] */
  *const nrrdKernelC3QuinticD,   /* 1st deriv of C3Quintic */
  *const nrrdKernelC3QuinticDD,  /* 2nd deriv of C3Quintic */
  *const nrrdKernelC4Hexic,      /* 0-parm C4 hex, support [-3,3] */
  *const nrrdKernelC4HexicD,     /* 1st deriv of C4Hexic */
  *const nrrdKernelC4HexicDD,    /* 2nd deriv of C4Hexic */
  *const nrrdKernelC4HexicDDD,   /* 3rd deriv of C4Hexic */
  *const nrrdKernelC4HexicApproxInverse,
  *const nrrdKernelC5Septic,     /* 0-parm C5 sept, support [-4,4] */
  *const nrrdKernelC5SepticD,    /* 1st deriv of C5Septic */
  *const nrrdKernelC5SepticDD,   /* 2nd deriv of C5Septic */
  *const nrrdKernelC5SepticDDD,  /* 3rd deriv of C5Septic */
  *const nrrdKernelC5SepticApproxInverse,
  *const nrrdKernelGaussian,     /* Gaussian */
  *const nrrdKernelGaussianD,    /* 1st derivative of Gaussian */
  *const nrrdKernelGaussianDD,   /* 2nd derivative of Gaussian */
  *const nrrdKernelDiscreteGaussian; /* Lindeberg's discrete Gaussian-like
                                        kernel for scale-space analysis */
/* clang-format on */
extern const double nrrdKernelDiscreteGaussianGoodSigmaMax;
extern int nrrdKernelParse(const NrrdKernel **kernelP,
                                double *parm,
                                const char *str);
extern int nrrdKernelSpecParse(NrrdKernelSpec *ksp, const char *str);
extern int nrrdKernelSpecSprint(char str[AIR_STRLEN_LARGE + 1],
                                     const NrrdKernelSpec *ksp);
extern int nrrdKernelSprint(char str[AIR_STRLEN_LARGE + 1],
                                 const NrrdKernel *kernel,
                                 const double kparm[NRRD_KERNEL_PARMS_NUM]);
extern int nrrdKernelCompare(const NrrdKernel *kernA,
                                  const double parmA[NRRD_KERNEL_PARMS_NUM],
                                  const NrrdKernel *kernB,
                                  const double parmB[NRRD_KERNEL_PARMS_NUM],
                                  int *differ,
                                  char explain[AIR_STRLEN_LARGE + 1]);
extern int nrrdKernelSpecCompare(const NrrdKernelSpec *aa,
                                      const NrrdKernelSpec *bb,
                                      int *differ,
                                      char explain[AIR_STRLEN_LARGE + 1]);
extern int nrrdKernelCheck(const NrrdKernel *kern,
                                const double parm[NRRD_KERNEL_PARMS_NUM], size_t evalNum,
                                double epsilon, unsigned int diffOkEvalMax,
                                unsigned int diffOkIntglMax, const NrrdKernel *dkern,
                                const double dparm[NRRD_KERNEL_PARMS_NUM]);
extern int nrrdKernelParm0IsScale(const NrrdKernel *kern);
extern const NrrdKernel *nrrdKernelDerivative(const NrrdKernel *kern);
/* ---- END non-NrrdIO */
