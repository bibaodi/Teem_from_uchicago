
/* NOTE: This file is a *very* hacked up version of the original
teem/alan.h, generated by build_teem.py to declare the alan API to
CFFI, within its many limitations, specifically lacking a C pre-processor
(so no #include directives, and only certain #defines). */
 /* =========== alan.h =========== */
/*
  Teem: Tools to process and visualize scientific data and images
  Copyright (C) 2009--2023  University of Chicago
  Copyright (C) 2005--2008  Gordon Kindlmann
  Copyright (C) 1998--2004  University of Utah
  This library is free software; you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License (LGPL) as published by the Free Software
  Foundation; either version 2.1 of the License, or (at your option) any later version.
  The terms of redistributing and/or modifying this software also include exceptions to
  the LGPL that facilitate static linking.
  This library is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public License along with
  this library; if not, write to Free Software Foundation, Inc., 51 Franklin Street,
  Fifth Floor, Boston, MA 02110-1301 USA
*/
#define ALAN_THREAD_MAX 256
enum {
  alanTextureTypeUnknown,
  alanTextureTypeTuring,
  alanTextureTypeGrayScott,
  alanTextureTypeLast
};
enum {
  alanParmUnknown,
  alanParmVerbose,
  alanParmTextureType,
  alanParmNumThreads,
  alanParmFrameInterval,
  alanParmHomogAniso,
  alanParmSaveInterval,
  alanParmMaxIteration,
  alanParmRandRange,
  alanParmDeltaT,
  alanParmDeltaX,
  alanParmDiffA,
  alanParmDiffB,
  alanParmReact,
  alanParmK,
  alanParmF,
  alanParmMinAverageChange,
  alanParmMaxPixelChange,
  alanParmAlpha,
  alanParmBeta,
  alanParmConstantFilename,
  alanParmWrapAround,
  alanParmLast
};
enum {
  alanStopUnknown = 0,
  alanStopNot,          /* 1 */
  alanStopMaxIteration, /* 2 */
  alanStopNonExist,     /* 3 */
  alanStopConverged,    /* 4 */
  alanStopDiverged,     /* 5 */
  alanStopLast
};
#define ALAN_STOP_MAX 5
/* all morphogen values are stored as
** 1: floats
** 0: doubles
*/
typedef float alan_t;
typedef struct alanContext_t {
  /* INPUT ----------------------------- */
  unsigned int dim,   /* either 2 or 3 */
    size[3],          /* number of texels in X, Y, (Z) */
    numThreads,       /* # of threads, if airThreadCapable */
    frameInterval,    /* # of iterations between which to an image */
    saveInterval,     /* # of iterations between which to save all state */
    maxIteration;     /* cap on # of iterations, or 0 if there is no limit */
  int verbose, wrap,  /* do toroidal boundary wrapping */
    textureType,      /* what kind are we (from alanTextureType* enum) */
    oversample,       /* oversampling of tensors to texels */
    homogAniso,       /* homogenous anisotropy approximation */
    constFilename;    /* always use the same filename when saving frames */
  alan_t K, F,        /* simulation variables */
    deltaX,           /* size of spatial grid discretization */
    minAverageChange, /* min worthwhile "avergageChange" value (see below),
                         assume convergence if it falls below this */
    maxPixelChange,   /* maximum allowed change in the first morphogen (on
                         any single pixels), assume unstable divergence if
                         this is exceeded */
    alpha, beta,      /* variables for turing */
    react,            /* additional scaling of reaction term */
    deltaT,           /* euler integration step size */
    initA, initB,     /* initial (constant) values for each morphogen */
    diffA, diffB,     /* base diffusion rates for each morphogen */
    randRange;        /* amplitude of noise to destabalize Turing */
  Nrrd *nten;         /* tensors guiding texture.  May have 1+3 or 1+6 values
                         per sample, depending on dim */
  /* if non-NULL, this is called once per iteration, at its completion */
  int (*perIteration)(struct alanContext_t *, int iter);
  /* INTERNAL -------------------------- */
  int iter;                 /* current iteration */
  Nrrd *_nlev[2],           /* levels of morphogens, alternating buffers */
    *nlev;                  /* pointer to last iterations output */
  Nrrd *nparm;              /* alpha, beta values for all texels */
  alan_t averageChange;     /* average amount of "change" in last iteration */
  unsigned int changeCount; /* # of contributions to averageChange
                               to control update of averageChange and changeCount */
  airThreadMutex *changeMutex;
  /* to synchronize separate iterations of simulation */
  airThreadBarrier *iterBarrier;
  /* OUTPUT ---------------------------- */
  int stop; /* why we stopped */
} alanContext;
/* methodsAlan.c */
extern const int alanPresent;
extern const char *const alanBiffKey;
extern void alanContextInit(alanContext *actx);
extern alanContext *alanContextNew(void);
extern alanContext *alanContextNix(alanContext *actx);
extern int alanDimensionSet(alanContext *actx, unsigned int dim);
extern int alan2DSizeSet(alanContext *actx, unsigned int sizeX, unsigned int sizeY);
extern int alan3DSizeSet(alanContext *actx, unsigned int sizeX, unsigned int sizeY,
                              unsigned int sizeZ);
extern int alanTensorSet(alanContext *actx, Nrrd *nten, int oversample);
extern int alanParmSet(alanContext *actx, int whichParm, double parm);
/* enumsAlan.c */
extern const airEnum *const alanStop;
/* coreAlan.c */
extern int alanUpdate(alanContext *actx);
extern int alanInit(alanContext *actx, const Nrrd *nlevInit, const Nrrd *nparmInit);
extern int alanRun(alanContext *actx);
